/* original parser id follows */
/* yysccsid[] = "@(#)yaccpar	1.9 (Berkeley) 02/21/93" */
/* (use YYMAJOR/YYMINOR for ifdefs dependent on parser version) */

#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 9
#define YYPATCH 20141006

#define YYEMPTY        (-1)
#define yyclearin      (yychar = YYEMPTY)
#define yyerrok        (yyerrflag = 0)
#define YYRECOVERING() (yyerrflag != 0)
#define YYENOMEM       (-2)
#define YYEOF          0
#define YYPREFIX "yy"

#define YYPURE 0

#line 40 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"

#include "defs.h"
#include "gdb_string.h"
#include <ctype.h>
#include "expression.h"
#include "value.h"
#include "parser-defs.h"
#include "language.h"
#include "c-lang.h"
#include "bfd.h" /* Required by objfiles.h.  */
#include "symfile.h" /* Required by objfiles.h.  */
#include "objfiles.h" /* For have_full_symbols and have_partial_symbols */
#include "charset.h"
#include "block.h"
#include "cp-support.h"

/* Flag indicating we're dealing with HP-compiled objects */ 
extern int hp_som_som_object_present;

/* Remap normal yacc parser interface names (yyparse, yylex, yyerror, etc),
   as well as gratuitiously global symbol names, so we can have multiple
   yacc generated parsers in gdb.  Note that these are only the variables
   produced by yacc.  If other parser generators (bison, byacc, etc) produce
   additional global names that conflict at link time, then those parser
   generators need to be fixed instead of adding those names to this list. */

#define	yymaxdepth c_maxdepth
#define	yyparse	c_parse
#define	yylex	c_lex
#define	yyerror	c_error
#define	yylval	c_lval
#define	yychar	c_char
#define	yydebug	c_debug
#define	yypact	c_pact	
#define	yyr1	c_r1			
#define	yyr2	c_r2			
#define	yydef	c_def		
#define	yychk	c_chk		
#define	yypgo	c_pgo		
#define	yyact	c_act		
#define	yyexca	c_exca
#define yyerrflag c_errflag
#define yynerrs	c_nerrs
#define	yyps	c_ps
#define	yypv	c_pv
#define	yys	c_s
#define	yy_yys	c_yys
#define	yystate	c_state
#define	yytmp	c_tmp
#define	yyv	c_v
#define	yy_yyv	c_yyv
#define	yyval	c_val
#define	yylloc	c_lloc
#define yyreds	c_reds		/* With YYDEBUG defined */
#define yytoks	c_toks		/* With YYDEBUG defined */
#define yyname	c_name		/* With YYDEBUG defined */
#define yyrule	c_rule		/* With YYDEBUG defined */
#define yylhs	c_yylhs
#define yylen	c_yylen
#define yydefred c_yydefred
#define yydgoto	c_yydgoto
#define yysindex c_yysindex
#define yyrindex c_yyrindex
#define yygindex c_yygindex
#define yytable	 c_yytable
#define yycheck	 c_yycheck

#ifndef YYDEBUG
#define	YYDEBUG 1		/* Default to yydebug support */
#endif

#define YYFPRINTF parser_fprintf

int yyparse (void);

static int yylex (void);

void yyerror (char *);

#line 125 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
#ifdef YYSTYPE
#undef  YYSTYPE_IS_DECLARED
#define YYSTYPE_IS_DECLARED 1
#endif
#ifndef YYSTYPE_IS_DECLARED
#define YYSTYPE_IS_DECLARED 1
typedef union
  {
    LONGEST lval;
    struct {
      LONGEST val;
      struct type *type;
    } typed_val_int;
    struct {
      DOUBLEST dval;
      struct type *type;
    } typed_val_float;
    struct symbol *sym;
    struct type *tval;
    struct stoken sval;
    struct ttype tsym;
    struct symtoken ssym;
    int voidval;
    struct block *bval;
    enum exp_opcode opcode;
    struct internalvar *ivar;

    struct type **tvec;
    int *ivec;
  } YYSTYPE;
#endif /* !YYSTYPE_IS_DECLARED */
#line 151 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
/* YYSTYPE gets defined by %union */
static int parse_number (char *, int, int, YYSTYPE *);
#line 136 "c-exp.c"

/* compatibility with bison */
#ifdef YYPARSE_PARAM
/* compatibility with FreeBSD */
# ifdef YYPARSE_PARAM_TYPE
#  define YYPARSE_DECL() yyparse(YYPARSE_PARAM_TYPE YYPARSE_PARAM)
# else
#  define YYPARSE_DECL() yyparse(void *YYPARSE_PARAM)
# endif
#else
# define YYPARSE_DECL() yyparse(void)
#endif

/* Parameters sent to lex. */
#ifdef YYLEX_PARAM
# define YYLEX_DECL() yylex(void *YYLEX_PARAM)
# define YYLEX yylex(YYLEX_PARAM)
#else
# define YYLEX_DECL() yylex(void)
# define YYLEX yylex()
#endif

/* Parameters sent to yyerror. */
#ifndef YYERROR_DECL
#define YYERROR_DECL() yyerror(const char *s)
#endif
#ifndef YYERROR_CALL
#define YYERROR_CALL(msg) yyerror(msg)
#endif

extern int YYPARSE_DECL();

#define INT 257
#define FLOAT 258
#define STRING 259
#define NAME 260
#define TYPENAME 261
#define NAME_OR_INT 262
#define STRUCT 263
#define CLASS 264
#define UNION 265
#define ENUM 266
#define SIZEOF 267
#define UNSIGNED 268
#define COLONCOLON 269
#define TEMPLATE 270
#define ERROR 271
#define SIGNED_KEYWORD 272
#define LONG 273
#define SHORT 274
#define INT_KEYWORD 275
#define CONST_KEYWORD 276
#define VOLATILE_KEYWORD 277
#define DOUBLE_KEYWORD 278
#define VARIABLE 279
#define ASSIGN_MODIFY 280
#define TRUEKEYWORD 281
#define FALSEKEYWORD 282
#define ABOVE_COMMA 283
#define OROR 284
#define ANDAND 285
#define EQUAL 286
#define NOTEQUAL 287
#define LEQ 288
#define GEQ 289
#define LSH 290
#define RSH 291
#define UNARY 292
#define INCREMENT 293
#define DECREMENT 294
#define ARROW 295
#define BLOCKNAME 296
#define FILENAME 297
#define YYERRCODE 256
typedef int YYINT;
static const YYINT yylhs[] = {                           -1,
    0,    0,    3,    2,    2,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,   22,    1,    6,   21,   21,   21,    7,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,   20,   20,   20,    4,    5,    5,
    4,    4,    4,   23,   24,   24,   26,   27,   27,   28,
   28,   14,   14,   14,   14,   14,   13,   13,   13,   13,
   13,   16,   16,   12,   12,    8,    8,    9,    9,    9,
    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
    9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
    9,    9,    9,    9,    9,    9,    9,    9,   10,   19,
   19,   19,   19,   11,   11,   15,   15,   29,   29,   25,
   25,   25,   17,   17,   17,   17,   18,   18,
};
static const YYINT yylen[] = {                            2,
    1,    1,    1,    1,    3,    2,    2,    2,    2,    2,
    2,    2,    2,    2,    2,    3,    3,    4,    3,    3,
    4,    4,    0,    5,    1,    0,    1,    3,    1,    3,
    4,    4,    3,    3,    3,    3,    3,    3,    3,    3,
    3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
    3,    3,    5,    3,    3,    1,    1,    1,    1,    1,
    4,    1,    1,    1,    1,    1,    3,    3,    3,    4,
    1,    2,    1,    2,    1,    0,    3,    1,    1,    1,
    0,    1,    2,    1,    2,    1,    3,    2,    1,    2,
    1,    2,    3,    2,    3,    1,    3,    1,    1,    1,
    1,    2,    3,    2,    3,    3,    3,    2,    2,    3,
    4,    3,    3,    4,    3,    4,    3,    4,    2,    3,
    2,    3,    2,    3,    1,    2,    2,    2,    2,    2,
    2,    1,    2,    1,    5,    2,    2,    1,    3,    1,
    1,    1,    1,    1,    3,    1,    4,    2,    2,    1,
    1,    1,    1,    1,    1,    1,    1,    1,
};
static const YYINT yydefred[] = {                         0,
   56,   58,   62,  157,   98,   57,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,   99,    0,    0,
  125,   60,   63,   64,    0,    0,    0,    0,    0,    0,
    0,   66,    0,    0,   25,    0,    0,    0,    2,   59,
   71,    0,    3,    0,  138,    0,   73,    0,    0,    0,
   78,    0,  150,  153,  155,  156,  154,  127,  128,  129,
  130,    0,    0,    0,  140,    0,    0,  141,  131,   72,
    0,    0,  143,  133,    0,    0,    0,  102,  126,    0,
    0,  119,  148,  149,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,   13,   14,    0,    0,    0,
   23,    0,    0,    0,    0,    0,  137,   80,    0,    0,
    0,    0,    0,    0,    0,    0,  106,  122,    0,    0,
  105,  107,  103,    0,    0,  110,  124,  120,   33,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,   17,   16,    0,   20,   19,    0,
    0,    0,   29,    0,    0,   30,   97,    0,    0,    0,
    0,    0,    0,   91,    0,    0,   89,    0,   74,   77,
   75,    0,    0,  116,    0,    0,  114,  118,  111,    0,
    0,    0,    0,   22,    0,    0,    0,   70,   85,   83,
    0,   92,   94,  144,    0,    0,    0,   90,   88,  147,
  139,  135,    0,    0,   24,   93,    0,   95,   87,  145,
};
static const YYINT yydgoto[] = {                         36,
   37,   90,   39,   40,   41,   42,  184,  224,   64,   45,
  225,  194,  195,  196,   46,  197,  189,   47,   69,   48,
  125,  181,  132,   49,   50,   51,   52,  129,   53,
};
static const YYINT yysindex[] = {                      2243,
    0,    0,    0,    0,    0,    0,    5,    5,    5,    5,
 2288, -224,    5,    5, -146, -255,   69,    0, -266, -242,
    0,    0,    0,    0, 2243, 2243, 2243, 2243, 2243, 2243,
    0,    0, 2243, 2243,    0,    0, 2626,   22,    0,    0,
    0, 2243,    0,   74,    0, -164,    0, -181,   26,    0,
    0, 1654,    0,    0,    0,    0,    0,    0,    0,    0,
    0, 2243,   28,   90,    0, -254, -178,    0,    0,    0,
   48, -249,    0,    0, -165, -145,  131,    0,    0, -122,
 -117,    0,    0,    0,   28,   28,   28,   28,   28,   77,
  127,   28,   28, 2243, 2243, 2243, 2243, 2243, 2243, 2243,
 2243, 2243, 2243, 2243, 2243, 2243, 2243, 2243, 2243, 2243,
 2243, 2243, 2243, 2243, 2243,    0,    0, 2084, 2663, 2243,
    0, 2243, 2626,   52,  -29,  -20,    0,    0,  270,    5,
  -53, -164,  101,  168,  -74,  -63,    0,    0, 1654,  -61,
    0,    0,    0,  -58,  -54,    0,    0,    0,    0, 2243,
 2626, 2626, 2591, 2689, 2700, 2728, 2761, 2796,  568,  568,
  -37,  -37,  -37,  -37,  173,  173,  374,  671,  671,   28,
   28,   28,    0, 2243,    0,    0, 2243,    0,    0,  -40,
 2243, 2626,    0, 2243, 2243,    0,    0,    5,    0,  155,
  -15,  -91,  977,    0,  -12, -164,    0,    0,    0,    0,
    0,    5, 2330,    0,  166,  132,    0,    0,    0,   28,
 2243,   28,   28,    0,  129,   28, 2626,    0,    0,    0,
  141,    0,    0,    0,  162,  197, 2735,    0,    0,    0,
    0,    0,  -35, 2661,    0,    0, 1654,    0,    0,    0,
};
static const YYINT yyrindex[] = {                       181,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
  181,   29,    0,    0,  545, 1852, 1991,    0, 1752, 1800,
    0,    0,    0,    0,  181,  181,  181,  181,  181,  181,
   99,    0,  181,  181,    0,    0,   14,  259,    0,    0,
    0,   -8,    0,  881,    0, 1859,    0,    0,    0, 1733,
    0,  181,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  181,  400,  181,    0, 2043, 2060,    0,    0,    0,
    0, 2043,    0,    0, 2095, 2112, 2125,    0,    0, 2140,
 2155,    0,    0,    0,  412,  440,  510,  580,  695,    0,
    0,  723,  791,  181,  181,  181,  181,  181,  181,  181,
  181,  181,  181,  181,  181,  181,  181,  181,  181,  181,
  181,  181,  181,  181,  181,    0,    0,  181,  181,  181,
    0,  181,  -11,    0,    0,    0,    0,    0,    0,    0,
    0, 1845, 2252,    0,    0, 2170,    0,    0,  181, 2183,
    0,    0,    0, 2200, 2213,    0,    0,    0,    0,  181,
   31,  150,    0,  239,  211, 1370, 1257, 1705,  111, 1687,
 1452, 1548, 1585, 1660, 1379, 1406, 1284, 1269, 1311,  845,
  899,  990,    1,  181,    0,    0,  181,    0,    0,    0,
  107,   16,    0,  181,  181,    0,    0,    0,   40, 1488,
  619,    0,  181,    0,  891, 3031,    0,  138,    0,    0,
    0,    0,  311,    0,    0,  836,    0,    0,    0, 1002,
  181, 1100, 1112,    0,    0, 1171,   -9,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  181,    0,    0,    0,
    0,    0,    0,  189,    0,    0,  181,    0,    0,    0,
};
static const YYINT yygindex[] = {                         0,
 3032,   12,    0,    0,    4,    0,  135,  105,  514,    0,
    0,   73,    0,   58,    0,   76, 1514,    0,  258,    0,
   98,    0,    0,  152,  161,    0,  301,  103,    0,
};
#define YYTABLESIZE 3243
static const YYINT yytable[] = {                        115,
  155,  222,  121,  122,  113,  111,  187,  112,  119,  114,
   83,   38,   75,    4,  185,    5,   76,   77,  136,   78,
  137,  187,   79,  140,  193,  141,  110,  227,  132,   27,
   55,   28,   27,   84,   28,   26,   65,  155,  155,   69,
  155,  155,  155,  155,  155,  155,  155,  155,   66,   67,
   68,  188,  214,  120,    4,   76,    5,    4,  155,    5,
  155,  155,  155,  155,   98,  122,  132,  121,  132,  132,
  132,   55,  132,  119,   55,  192,   69,   69,  192,   69,
   69,   69,   69,   69,   69,   69,   69,  130,   55,  131,
  132,  155,  132,  155,  155,  183,  138,   69,  158,   69,
   69,   69,   69,   69,   43,  188,    4,  139,    5,  142,
   42,   19,   20,   27,   65,   28,   26,  149,  120,  132,
  122,  175,  178,   55,  155,  155,   72,   73,   68,  143,
   69,  180,   69,   69,   91,  158,  158,   68,  158,  158,
  158,  158,  158,  158,  158,  158,  124,   26,   42,   54,
   26,   42,  147,  132,   42,   55,  158,  148,  158,  158,
  158,  158,  158,   69,   69,  221,  134,  150,   42,  235,
   76,   42,  185,   42,   68,   68,  183,   68,   68,   68,
   68,   68,   68,   68,   68,   54,   55,   56,   53,  158,
   54,  158,  158,   54,  193,   68,  191,   68,   68,   68,
   68,   68,  238,   42,   42,  237,  199,   54,  203,  115,
   51,  204,  121,  207,  113,  111,  208,  112,  119,  114,
  209,   57,  158,  158,   54,   55,   56,  232,   68,   53,
   68,   68,   53,  236,   42,   42,  110,  239,   52,   54,
   55,   56,   54,  205,   76,  192,   53,  219,  220,   53,
  226,   51,  108,  109,   51,  116,  117,  118,    1,  186,
   57,   68,   68,  120,   54,   55,   56,  228,   51,   98,
  229,   51,   74,   51,   54,   57,   98,   98,  215,   52,
  155,   53,   52,  200,  155,  155,  155,  155,  155,  155,
  155,  155,  201,  155,  155,  155,   52,  132,  230,   52,
   57,   52,    0,   51,  132,  132,    0,  190,  139,  193,
   61,  191,    0,   53,    0,  139,  139,    0,    0,   69,
  116,  117,  118,   69,   69,   69,   69,   69,   69,   69,
   69,   52,   69,   69,   69,   51,   80,    0,    0,    0,
   81,  240,  126,   82,  127,    0,  128,   61,   61,   19,
   20,   61,   61,   61,   61,   61,   61,   61,  135,    0,
  192,    0,    0,   52,  127,   19,   20,   65,   61,  202,
   61,   61,   61,   61,   61,    0,   19,   20,  158,    0,
    0,    0,  158,  158,  158,  158,  158,  158,  158,  158,
   42,  158,  158,  158,   42,   42,   42,   42,  144,   15,
  233,   61,  145,   61,   61,  146,   67,   19,   20,    0,
  115,    7,    0,  121,    0,  113,  111,   68,  112,  119,
  114,   68,   68,   68,   68,   68,   68,   68,   68,    0,
   68,   68,   68,  127,   61,   61,   15,   15,    0,    8,
   15,   15,   15,   15,   15,    0,   15,    0,    7,    7,
    0,    0,    7,    7,    7,    7,    7,   15,    7,   15,
   15,   15,   15,   15,  120,  116,  117,  118,   53,    7,
    0,    7,    7,    7,    7,    7,    8,    8,    0,    0,
    8,    8,    8,    8,    8,    0,    8,    0,    0,    0,
   51,    0,   15,   15,   51,   51,  128,    8,    0,    8,
    8,    8,    8,    8,    7,    7,  127,    0,    0,    6,
    0,    0,    0,   44,    0,    0,    0,    0,   52,    0,
    0,    0,   52,   15,   15,    0,    0,    0,    0,    0,
    0,    0,    8,    8,    0,    7,    7,    0,    0,    0,
    0,    0,    0,   44,  134,    0,    6,    6,    0,    0,
    6,    6,    6,    6,    6,   44,    6,    0,    0,    0,
    0,    0,    0,    8,    8,  133,    0,    6,    0,    6,
    6,    6,    6,    6,    0,   44,    0,    0,    0,   11,
    0,    0,  134,    0,  134,  134,  134,    0,  134,    0,
   61,    0,    0,    0,   61,   61,   61,   61,   61,   61,
   61,   61,    6,    6,  115,   61,  134,  121,  134,  113,
  111,    0,  112,  119,  114,    0,   11,   11,   82,    0,
   11,   11,   11,   11,   11,    0,   11,  104,    0,  105,
    0,  110,    0,    6,    6,  134,    0,   11,    0,   11,
   11,   11,   11,   11,    0,    0,    0,    0,    0,    0,
    0,    0,  206,    0,    0,    0,   82,    0,  120,   82,
   82,    0,   82,    0,    0,    0,  116,  117,  118,  134,
    0,    0,   11,   11,    0,    0,    0,    0,    0,   15,
   82,    0,   82,   15,   15,   15,   15,   15,   15,   15,
   15,    7,    0,    0,   12,    7,    7,    7,    7,    7,
    7,    7,    7,   11,   11,    0,  206,  115,    0,    0,
  121,    0,  113,    0,    0,    0,  119,  114,    0,    8,
    0,    0,    9,    8,    8,    8,    8,    8,    8,    8,
    8,   12,   12,    0,    0,   12,   12,   12,   12,   12,
  206,   12,    0,   82,    0,    0,    0,    0,    0,    0,
  206,    0,   12,    0,   12,   12,   12,   12,   12,    9,
    9,  120,    0,    9,    9,    9,    9,    9,    0,    9,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    9,    0,    9,    9,    9,    9,    9,   12,   12,    6,
   10,    0,    0,    6,    6,    6,    6,    6,    6,    6,
    6,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  134,    0,    9,    9,    0,   12,   12,
  134,  134,    0,    0,    0,    0,    0,   10,   10,    0,
    0,   10,   10,   10,   10,   10,    0,   10,    0,    0,
    0,    0,    0,    0,   35,    0,    9,    9,   10,    0,
   10,   10,   10,   10,   10,  106,  107,  108,  109,   11,
  116,  117,  118,   11,   11,   11,   11,   11,   11,   11,
   11,    0,    0,  146,    0,  146,  146,  146,    0,  146,
  146,   35,   35,   10,   10,   35,   35,   35,   35,   35,
   86,   35,    0,    0,   82,   82,    0,  146,   36,   76,
    0,    0,   35,    0,   35,   35,   35,   35,   35,    0,
    0,    0,    0,    0,   10,   10,    0,    0,  146,    0,
  146,  146,  146,    0,    0,    0,  146,    0,   86,    0,
    0,   86,   86,    0,   86,   36,   36,   35,   35,   36,
   36,   36,   36,   36,   76,   36,    0,    0,    0,    0,
    0,    0,   86,    0,   86,    0,   36,    0,   36,   36,
   36,   36,   36,  116,  117,  118,    0,    0,   35,   35,
    0,  146,    0,    0,   12,    0,    0,    0,   12,   12,
   12,   12,   12,   12,   12,   12,    0,    0,    0,   37,
    0,   36,   36,    0,    0,    0,    0,    0,    0,    0,
    0,   32,    9,    0,    0,  146,    9,    9,    9,    9,
    9,    9,    9,    9,  190,   86,  193,  223,  191,    0,
    0,    0,   36,   36,    0,    0,   37,   37,    0,    0,
   37,   37,   37,   37,   37,    0,   37,    0,   32,   32,
    0,    0,   32,   32,   32,   32,   32,   37,   32,   37,
   37,   37,   37,   37,    0,    0,    0,    0,    0,   32,
    0,   32,   32,   32,   32,   32,    0,  192,    0,    0,
   10,    0,    0,    0,   10,   10,   10,   10,   10,   10,
   10,   10,   37,   37,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,   32,   32,    0,    0,    0,   18,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,   21,    0,   37,   37,    0,    0,    0,    0,    0,
    0,    0,    0,    0,   35,   32,   32,    0,   35,   35,
   35,   35,   35,   35,   35,   35,   18,   18,    0,    0,
   18,   18,   18,   18,   18,    0,   18,    0,   21,   21,
    0,    0,   21,   21,   21,   21,   21,   18,   21,   18,
   18,   18,   18,   18,    0,    0,   86,   86,    0,   21,
   31,   21,   21,   21,   21,   21,    0,    0,   36,    0,
    0,    0,   36,   36,   36,   36,   36,   36,   36,   36,
    0,    0,   18,   18,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,   21,   21,    0,   31,   31,    0,
    0,   31,   31,   31,   31,   31,    0,   31,    0,    0,
    0,    0,    0,   18,   18,    0,    0,    0,   31,    0,
   31,   31,   31,   31,   31,   21,   21,    5,    0,    7,
    8,    9,   10,    0,   12,    0,   14,    0,   15,   16,
   17,   18,   19,   20,   21,    0,   49,    0,    0,    0,
    0,    0,    0,   31,   31,    0,    0,    0,   38,   37,
    0,    0,    0,   37,   37,   37,   37,   37,   37,   37,
   37,   32,    0,   34,    0,   32,   32,   32,   32,   32,
   32,   32,   32,    0,   31,   31,    0,   49,    0,    0,
   49,    0,    0,    0,    0,    0,   38,    0,    0,   38,
   39,   38,   38,   38,   49,    0,    0,   49,    0,   49,
    0,   34,    0,    0,   34,    0,   38,   34,   38,   38,
   38,   38,   38,    0,    0,    0,    0,    0,    0,    0,
    0,   34,    0,   34,   34,   34,   34,   34,   39,   49,
   49,   39,    0,   39,   39,   39,    0,    0,    0,    0,
    0,   38,   38,    0,    0,    0,    0,    0,   39,   50,
   39,   39,   39,   39,   39,    0,   34,   34,   40,   18,
   49,   49,    0,   18,   18,   18,   18,   18,   18,   18,
   18,   21,   38,   38,    0,   21,   21,   21,   21,   21,
   21,   21,   21,   39,   39,   41,    0,   34,   34,    0,
   50,    0,    0,   50,    0,    0,   40,    0,    0,   40,
    0,    0,   40,    0,    0,    0,    0,   50,    0,    0,
   50,    0,   50,    0,   39,   39,   40,    0,   40,   40,
   40,   40,    0,   41,    0,    0,   41,    0,    0,   41,
   31,   46,    0,    0,   31,   31,   31,   31,   31,   31,
   31,   31,   50,   41,    0,   41,   41,   41,   41,    0,
    0,   40,   40,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,   84,    0,   46,
    0,    0,   46,   50,   50,   46,    0,    0,   41,   41,
    0,    0,   40,   40,    0,    0,    0,    0,    0,   46,
    0,   46,   46,   46,   46,    0,    0,    0,    0,    0,
   58,   59,   60,   61,    0,   84,   70,   71,   84,   41,
   41,   84,    0,    0,    0,    0,   49,    0,    0,    0,
   49,   49,    0,    0,   46,   46,    0,   47,   38,   84,
    0,   84,   38,   38,   38,   38,   38,   38,   38,   38,
    0,    0,    0,   34,    0,    0,    0,   34,   34,   34,
   34,   34,   34,   34,   34,   46,   46,    0,    0,    0,
    0,    0,    0,    0,   44,   47,    0,    0,   47,    0,
   39,   47,    0,    0,   39,   39,   39,   39,   39,   39,
   39,   39,    0,    0,    0,   47,    0,   47,   47,   47,
   47,    0,   84,    0,    0,    0,    0,    0,    0,    0,
    0,    0,   44,    0,    0,   44,    0,    0,   44,    0,
    0,  176,  179,    0,    0,    0,    0,    0,    0,    0,
   47,   47,   44,  198,   44,   44,   44,   44,    0,   50,
    0,    0,    0,   50,   50,    0,    0,    0,   40,   45,
    0,    0,   40,   40,   40,   40,   40,   40,   40,   40,
    0,   47,   47,    0,    0,    0,    0,   44,   44,    0,
    0,    0,    0,    0,    0,   41,   43,    0,    0,   41,
   41,   41,   41,   41,   41,   41,   41,   45,    0,    0,
   45,  218,    0,   45,   48,    0,    0,    0,   44,   44,
    0,    0,    0,    0,    0,  231,    0,   45,    0,   45,
   45,   45,   45,    0,   43,    0,    0,   43,    0,    0,
   43,   46,   79,    0,    0,   46,   46,   46,   46,   46,
   46,    0,   48,    0,   43,   48,  231,   43,   48,   43,
    0,  151,   45,   45,    0,    0,    0,    0,    0,    0,
    0,    0,   48,   84,   84,   48,    0,   48,    0,    0,
   79,    0,   79,   79,   79,    0,   79,    0,    0,   43,
   43,    0,    0,   45,   45,    0,    0,    0,    0,  151,
    0,  151,  151,  151,   79,  151,   75,   48,   48,  152,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   43,   43,    0,  151,    0,  151,    0,    0,    0,    0,
    0,    0,    0,   79,    0,    0,    0,   47,   48,   48,
    0,   47,   47,   47,   47,   47,   47,  152,    0,  152,
  152,  152,  151,  152,   76,    0,    0,    0,    0,    0,
    0,  100,    0,    0,    0,    0,    0,   79,   96,    0,
    0,  152,    0,  152,   44,    0,    0,    0,   44,   44,
   44,   44,   44,   44,    0,    0,  151,    0,    0,    0,
    0,    0,   76,    0,   76,   76,   76,    0,   76,  100,
  152,  100,  100,  100,    0,  100,   81,    0,   81,   96,
   81,    0,   96,    0,    0,    0,   76,    0,   76,    0,
    0,    0,    0,  100,    5,  100,    7,    8,    9,   10,
   96,   12,   76,   14,  152,   15,   16,   17,   18,   19,
   20,   21,    0,    0,    0,   76,    0,    0,    0,   45,
    0,    0,  100,   45,   45,   45,   45,   45,   45,   81,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   43,    0,    0,   76,
   43,   43,   43,   43,    0,    0,  100,    0,    0,    0,
    0,    0,    0,   96,   48,    0,    0,    0,   48,   48,
  101,    0,    0,   79,    0,   79,   79,   79,   79,    0,
   79,   79,   79,    0,   79,   79,   79,   79,   79,   79,
   79,    0,  151,    0,  151,  151,  151,  151,    0,  151,
  151,  151,    0,  151,  151,  151,  151,  151,  101,  151,
  101,  101,  101,    0,  101,    0,    0,    0,    0,    0,
    0,    0,  142,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  101,    0,  101,    0,    0,    0,    0,  143,
  152,    0,  152,  152,  152,  152,    0,  152,  152,  152,
    0,  152,  152,  152,  152,    0,  152,  152,    0,    0,
  142,  101,  142,  142,  142,    0,  142,    0,    0,    0,
    0,    0,    0,    0,  108,    0,    0,  143,    0,  143,
  143,  143,    0,  143,  142,   76,  142,   76,   76,   76,
   76,  104,   76,   76,   76,  101,   76,   76,   76,   76,
  100,  143,   76,  143,  109,  174,    0,  100,  100,    0,
    0,    0,  108,  142,  108,  108,  108,    0,  108,  123,
    0,    0,    0,    0,    0,    0,    0,    0,    0,  104,
  143,  104,  104,  104,  121,  104,  108,    0,  108,    0,
    0,    0,  109,    0,  109,  109,  109,  142,  109,  115,
    0,    0,    0,  104,    0,  104,    0,  123,    0,  123,
  123,  123,  113,  123,  143,  108,  109,    0,  109,    0,
    0,    0,  121,    0,  121,  121,  121,    0,  121,  117,
    0,  123,  104,  123,    0,    0,    0,  115,    0,  115,
  115,  115,  112,  115,    0,  109,  121,    0,  121,  108,
  113,    0,  113,  113,  113,    0,  113,    0,    0,    0,
  123,  115,    0,  115,    0,    0,  104,  117,    0,  117,
  117,  117,    0,  117,  113,  121,  113,    0,    0,  109,
  112,  136,  112,  112,  112,    0,  112,    0,    0,  101,
  115,  117,    0,  117,  123,    0,  101,  101,    0,    0,
    0,    0,    0,  113,  112,   33,  112,    0,    0,  121,
   25,    0,   30,    0,   27,    0,    0,   26,    0,  136,
  117,  136,  136,  136,  115,  136,    0,    0,    0,    0,
    0,    0,    0,  112,    0,    0,    0,  113,    0,    0,
    0,  142,    0,  136,    0,   76,    0,    0,  142,  142,
   33,    0,    0,    0,  117,   25,    0,   62,  143,   27,
    0,    0,   26,    0,    0,  143,  143,  112,    0,    0,
    0,    0,  136,   54,  173,   56,    7,    8,    9,   10,
    0,   12,    0,   14,    0,   15,   16,   17,   18,   19,
   20,   21,   33,  108,    0,   35,    0,    0,   34,   30,
  108,  108,    0,    0,    0,    0,  136,    0,    0,   57,
  104,    0,    0,    0,    0,    0,    0,  104,  104,    0,
    0,    0,    0,  109,    0,    0,    0,    0,    0,    0,
  109,  109,    0,    0,    0,    0,    0,    0,  123,    0,
   35,    0,    0,   34,    0,  123,  123,    0,    0,    0,
    0,    0,    0,  121,    0,    0,    0,    0,    0,    0,
  121,  121,    0,    0,    0,    0,    0,    0,  115,    0,
    0,    0,    0,    0,    0,  115,  115,    0,    0,    0,
    0,  113,   35,    0,    0,   34,    0,    0,  113,  113,
    0,    0,    0,    0,    0,    0,    0,    0,  117,    0,
    0,    0,    0,    0,    0,  117,  117,    0,    0,    0,
    0,  112,    0,    0,    0,    0,    0,    0,  112,  112,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    1,
    2,    3,    4,    5,    6,    7,    8,    9,   10,   11,
   12,   13,   14,    0,   15,   16,   17,   18,   19,   20,
   21,   22,    0,   23,   24,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,   28,   29,    0,   31,   32,
    0,    0,    0,    0,    1,    2,    3,    4,    5,    6,
    7,    8,    9,   10,   11,   12,   13,   14,    0,   15,
   16,   17,   18,   19,   20,   21,   22,    0,   23,   24,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   28,   29,    0,   31,   32,    0,    1,    2,    3,    4,
    5,    6,    7,    8,    9,   10,   11,   12,   13,   14,
    0,   15,   16,   17,   18,   19,   20,   21,   22,    0,
   23,   24,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,   28,   29,    0,   31,   32,  115,  101,    0,
  121,    0,  113,  111,    0,  112,  119,  114,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  211,    0,
  104,   95,  105,   96,  110,    0,    0,    0,    0,    0,
    0,    0,  115,  101,    0,  121,    0,  113,  111,    0,
  112,  119,  114,    0,    0,    0,    0,    0,    0,    0,
    0,  120,    0,    0,  100,  104,   95,  105,   96,  110,
    0,    0,    0,    0,    0,    0,    0,  115,  101,    0,
  121,    0,  113,  111,  177,  112,  119,  114,    0,    0,
    0,    0,    0,    0,   99,    0,  120,    0,    0,  100,
  104,    0,  105,   96,  110,  115,  101,    0,  121,    0,
  113,  111,    0,  112,  119,  114,  115,  101,    0,  121,
    0,  113,  111,    0,  112,  119,  114,    0,  104,   99,
  105,  120,  110,    0,  100,    0,    0,    0,    0,  104,
    0,  105,    0,  110,  115,  101,    0,  121,    0,  113,
  111,    0,  112,  119,  114,  223,    0,    0,    0,  120,
    0,    0,  100,    0,   99,    0,    0,  104,    0,  105,
  120,  110,    0,  100,    0,    0,    0,  115,  101,    0,
  121,    0,  113,  111,    0,  112,  119,  114,    0,    0,
    0,    0,   99,    0,    0,    0,    0,    0,  120,    0,
  104,  100,  105,   99,  110,    0,    0,    0,    0,    0,
    0,    0,  115,    0,    0,  121,    0,  113,  111,    0,
  112,  119,  114,    0,    0,    0,    0,    0,    0,    0,
    0,  120,    0,    0,    0,  104,    0,  105,    0,  110,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   94,    0,    0,    0,   97,   98,  102,  103,  106,  107,
  108,  109,    0,  116,  117,  118,  120,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,   94,    0,    0,    0,   97,
   98,  102,  103,  106,  107,  108,  109,    0,  116,  117,
  118,    0,   54,  173,   56,    7,    8,    9,   10,    0,
   12,    0,   14,    0,   15,   16,   17,   18,   19,   20,
   21,    0,    0,    0,   97,   98,  102,  103,  106,  107,
  108,  109,    0,  116,  117,  118,    0,    0,   57,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,   98,  102,  103,  106,  107,  108,  109,
    0,  116,  117,  118,    0,  102,  103,  106,  107,  108,
  109,    0,  116,  117,  118,    5,    0,    7,    8,    9,
   10,    0,   12,    0,   14,    0,   15,   16,   17,   18,
   19,   20,   21,  102,  103,  106,  107,  108,  109,    0,
  116,  117,  118,    0,    0,    0,    0,    0,    0,    0,
   81,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,   63,    0,    0,    0,  102,  103,  106,  107,
  108,  109,    0,  116,  117,  118,   85,   86,   87,   88,
   89,    0,    0,    0,   92,   93,    0,    0,   81,    0,
   81,   81,   81,  123,   81,    0,    0,    0,    0,    0,
    0,  102,  103,  106,  107,  108,  109,    0,  116,  117,
  118,    0,   81,    0,   76,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,   81,    0,    0,    0,  151,  152,  153,  154,  155,
  156,  157,  158,  159,  160,  161,  162,  163,  164,  165,
  166,  167,  168,  169,  170,  171,  172,    0,    0,    0,
    0,    0,    0,  182,    0,   81,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  210,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  212,    0,    0,  213,    0,
    0,    0,  123,    0,    0,  216,  217,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  210,    0,    0,    0,    0,    0,
    0,    0,  234,
};
static const YYINT yycheck[] = {                         37,
    0,   93,   40,   44,   42,   43,   42,   45,   46,   47,
  277,    0,  268,    0,   44,    0,  272,  273,  273,  275,
  275,   42,  278,  273,   40,  275,   64,   40,    0,   41,
    0,   41,   44,  276,   44,   44,  261,   37,   38,    0,
   40,   41,   42,   43,   44,   45,   46,   47,  273,  274,
  275,  126,   93,   91,   41,   64,   41,   44,   58,   44,
   60,   61,   62,   63,   64,   44,   38,   40,   40,   41,
   42,   41,   44,   46,   44,   91,   37,   38,   91,   40,
   41,   42,   43,   44,   45,   46,   47,  269,   58,   64,
   62,   91,   64,   93,   94,  125,  275,   58,    0,   60,
   61,   62,   63,   64,    0,  126,   93,   60,   93,  275,
    0,  276,  277,  125,  261,  125,  125,   41,   91,   91,
   44,  118,  119,   93,  124,  125,  273,  274,  275,  275,
   91,  120,   93,   94,   30,   37,   38,    0,   40,   41,
   42,   43,   44,   45,   46,   47,   42,   41,   38,    0,
   44,   41,  275,  125,   44,  125,   58,  275,   60,   61,
   62,   63,   64,  124,  125,  257,   62,   41,   58,   41,
   64,   61,   44,   63,   37,   38,  125,   40,   41,   42,
   43,   44,   45,   46,   47,  260,  261,  262,    0,   91,
   41,   93,   94,   44,   40,   58,   42,   60,   61,   62,
   63,   64,   41,   93,   94,   44,  260,   58,   41,   37,
    0,  275,   40,  275,   42,   43,  275,   45,   46,   47,
  275,  296,  124,  125,  260,  261,  262,   62,   91,   41,
   93,   94,   44,   93,  124,  125,   64,   41,    0,  260,
  261,  262,   93,  139,   64,   91,   58,  190,  191,   61,
  193,   41,  290,  291,   44,  293,  294,  295,    0,  125,
  296,  124,  125,   91,  260,  261,  262,  195,   58,  269,
  195,   61,   15,   63,  125,  296,  276,  277,  181,   41,
  280,   93,   44,  132,  284,  285,  286,  287,  288,  289,
  290,  291,  132,  293,  294,  295,   58,  269,  196,   61,
  296,   63,   -1,   93,  276,  277,   -1,   38,  269,   40,
    0,   42,   -1,  125,   -1,  276,  277,   -1,   -1,  280,
  293,  294,  295,  284,  285,  286,  287,  288,  289,  290,
  291,   93,  293,  294,  295,  125,  268,   -1,   -1,   -1,
  272,  237,  269,  275,   44,   -1,   46,   37,   38,  276,
  277,   41,   42,   43,   44,   45,   46,   47,  269,   -1,
   91,   -1,   -1,  125,   64,  276,  277,  269,   58,  269,
   60,   61,   62,   63,   64,   -1,  276,  277,  280,   -1,
   -1,   -1,  284,  285,  286,  287,  288,  289,  290,  291,
  280,  293,  294,  295,  284,  285,  286,  287,  268,    0,
  269,   91,  272,   93,   94,  275,  269,  276,  277,   -1,
   37,    0,   -1,   40,   -1,   42,   43,  280,   45,   46,
   47,  284,  285,  286,  287,  288,  289,  290,  291,   -1,
  293,  294,  295,  133,  124,  125,   37,   38,   -1,    0,
   41,   42,   43,   44,   45,   -1,   47,   -1,   37,   38,
   -1,   -1,   41,   42,   43,   44,   45,   58,   47,   60,
   61,   62,   63,   64,   91,  293,  294,  295,  280,   58,
   -1,   60,   61,   62,   63,   64,   37,   38,   -1,   -1,
   41,   42,   43,   44,   45,   -1,   47,   -1,   -1,   -1,
  280,   -1,   93,   94,  284,  285,  196,   58,   -1,   60,
   61,   62,   63,   64,   93,   94,  206,   -1,   -1,    0,
   -1,   -1,   -1,    0,   -1,   -1,   -1,   -1,  280,   -1,
   -1,   -1,  284,  124,  125,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   93,   94,   -1,  124,  125,   -1,   -1,   -1,
   -1,   -1,   -1,   30,    0,   -1,   37,   38,   -1,   -1,
   41,   42,   43,   44,   45,   42,   47,   -1,   -1,   -1,
   -1,   -1,   -1,  124,  125,   52,   -1,   58,   -1,   60,
   61,   62,   63,   64,   -1,   62,   -1,   -1,   -1,    0,
   -1,   -1,   38,   -1,   40,   41,   42,   -1,   44,   -1,
  280,   -1,   -1,   -1,  284,  285,  286,  287,  288,  289,
  290,  291,   93,   94,   37,  295,   62,   40,   64,   42,
   43,   -1,   45,   46,   47,   -1,   37,   38,    0,   -1,
   41,   42,   43,   44,   45,   -1,   47,   60,   -1,   62,
   -1,   64,   -1,  124,  125,   91,   -1,   58,   -1,   60,
   61,   62,   63,   64,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  139,   -1,   -1,   -1,   38,   -1,   91,   41,
   42,   -1,   44,   -1,   -1,   -1,  293,  294,  295,  125,
   -1,   -1,   93,   94,   -1,   -1,   -1,   -1,   -1,  280,
   62,   -1,   64,  284,  285,  286,  287,  288,  289,  290,
  291,  280,   -1,   -1,    0,  284,  285,  286,  287,  288,
  289,  290,  291,  124,  125,   -1,  193,   37,   -1,   -1,
   40,   -1,   42,   -1,   -1,   -1,   46,   47,   -1,  280,
   -1,   -1,    0,  284,  285,  286,  287,  288,  289,  290,
  291,   37,   38,   -1,   -1,   41,   42,   43,   44,   45,
  227,   47,   -1,  125,   -1,   -1,   -1,   -1,   -1,   -1,
  237,   -1,   58,   -1,   60,   61,   62,   63,   64,   37,
   38,   91,   -1,   41,   42,   43,   44,   45,   -1,   47,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   58,   -1,   60,   61,   62,   63,   64,   93,   94,  280,
    0,   -1,   -1,  284,  285,  286,  287,  288,  289,  290,
  291,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  269,   -1,   93,   94,   -1,  124,  125,
  276,  277,   -1,   -1,   -1,   -1,   -1,   37,   38,   -1,
   -1,   41,   42,   43,   44,   45,   -1,   47,   -1,   -1,
   -1,   -1,   -1,   -1,    0,   -1,  124,  125,   58,   -1,
   60,   61,   62,   63,   64,  288,  289,  290,  291,  280,
  293,  294,  295,  284,  285,  286,  287,  288,  289,  290,
  291,   -1,   -1,   38,   -1,   40,   41,   42,   -1,   44,
    0,   37,   38,   93,   94,   41,   42,   43,   44,   45,
    0,   47,   -1,   -1,  276,  277,   -1,   62,    0,   64,
   -1,   -1,   58,   -1,   60,   61,   62,   63,   64,   -1,
   -1,   -1,   -1,   -1,  124,  125,   -1,   -1,   38,   -1,
   40,   41,   42,   -1,   -1,   -1,   91,   -1,   38,   -1,
   -1,   41,   42,   -1,   44,   37,   38,   93,   94,   41,
   42,   43,   44,   45,   64,   47,   -1,   -1,   -1,   -1,
   -1,   -1,   62,   -1,   64,   -1,   58,   -1,   60,   61,
   62,   63,   64,  293,  294,  295,   -1,   -1,  124,  125,
   -1,   91,   -1,   -1,  280,   -1,   -1,   -1,  284,  285,
  286,  287,  288,  289,  290,  291,   -1,   -1,   -1,    0,
   -1,   93,   94,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,    0,  280,   -1,   -1,  125,  284,  285,  286,  287,
  288,  289,  290,  291,   38,  125,   40,   41,   42,   -1,
   -1,   -1,  124,  125,   -1,   -1,   37,   38,   -1,   -1,
   41,   42,   43,   44,   45,   -1,   47,   -1,   37,   38,
   -1,   -1,   41,   42,   43,   44,   45,   58,   47,   60,
   61,   62,   63,   64,   -1,   -1,   -1,   -1,   -1,   58,
   -1,   60,   61,   62,   63,   64,   -1,   91,   -1,   -1,
  280,   -1,   -1,   -1,  284,  285,  286,  287,  288,  289,
  290,  291,   93,   94,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   93,   94,   -1,   -1,   -1,    0,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,    0,   -1,  124,  125,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,  280,  124,  125,   -1,  284,  285,
  286,  287,  288,  289,  290,  291,   37,   38,   -1,   -1,
   41,   42,   43,   44,   45,   -1,   47,   -1,   37,   38,
   -1,   -1,   41,   42,   43,   44,   45,   58,   47,   60,
   61,   62,   63,   64,   -1,   -1,  276,  277,   -1,   58,
    0,   60,   61,   62,   63,   64,   -1,   -1,  280,   -1,
   -1,   -1,  284,  285,  286,  287,  288,  289,  290,  291,
   -1,   -1,   93,   94,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   93,   94,   -1,   37,   38,   -1,
   -1,   41,   42,   43,   44,   45,   -1,   47,   -1,   -1,
   -1,   -1,   -1,  124,  125,   -1,   -1,   -1,   58,   -1,
   60,   61,   62,   63,   64,  124,  125,  261,   -1,  263,
  264,  265,  266,   -1,  268,   -1,  270,   -1,  272,  273,
  274,  275,  276,  277,  278,   -1,    0,   -1,   -1,   -1,
   -1,   -1,   -1,   93,   94,   -1,   -1,   -1,    0,  280,
   -1,   -1,   -1,  284,  285,  286,  287,  288,  289,  290,
  291,  280,   -1,    0,   -1,  284,  285,  286,  287,  288,
  289,  290,  291,   -1,  124,  125,   -1,   41,   -1,   -1,
   44,   -1,   -1,   -1,   -1,   -1,   38,   -1,   -1,   41,
    0,   43,   44,   45,   58,   -1,   -1,   61,   -1,   63,
   -1,   38,   -1,   -1,   41,   -1,   58,   44,   60,   61,
   62,   63,   64,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   58,   -1,   60,   61,   62,   63,   64,   38,   93,
   94,   41,   -1,   43,   44,   45,   -1,   -1,   -1,   -1,
   -1,   93,   94,   -1,   -1,   -1,   -1,   -1,   58,    0,
   60,   61,   62,   63,   64,   -1,   93,   94,    0,  280,
  124,  125,   -1,  284,  285,  286,  287,  288,  289,  290,
  291,  280,  124,  125,   -1,  284,  285,  286,  287,  288,
  289,  290,  291,   93,   94,    0,   -1,  124,  125,   -1,
   41,   -1,   -1,   44,   -1,   -1,   38,   -1,   -1,   41,
   -1,   -1,   44,   -1,   -1,   -1,   -1,   58,   -1,   -1,
   61,   -1,   63,   -1,  124,  125,   58,   -1,   60,   61,
   62,   63,   -1,   38,   -1,   -1,   41,   -1,   -1,   44,
  280,    0,   -1,   -1,  284,  285,  286,  287,  288,  289,
  290,  291,   93,   58,   -1,   60,   61,   62,   63,   -1,
   -1,   93,   94,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,    0,   -1,   38,
   -1,   -1,   41,  124,  125,   44,   -1,   -1,   93,   94,
   -1,   -1,  124,  125,   -1,   -1,   -1,   -1,   -1,   58,
   -1,   60,   61,   62,   63,   -1,   -1,   -1,   -1,   -1,
    7,    8,    9,   10,   -1,   38,   13,   14,   41,  124,
  125,   44,   -1,   -1,   -1,   -1,  280,   -1,   -1,   -1,
  284,  285,   -1,   -1,   93,   94,   -1,    0,  280,   62,
   -1,   64,  284,  285,  286,  287,  288,  289,  290,  291,
   -1,   -1,   -1,  280,   -1,   -1,   -1,  284,  285,  286,
  287,  288,  289,  290,  291,  124,  125,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,    0,   38,   -1,   -1,   41,   -1,
  280,   44,   -1,   -1,  284,  285,  286,  287,  288,  289,
  290,  291,   -1,   -1,   -1,   58,   -1,   60,   61,   62,
   63,   -1,  125,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   38,   -1,   -1,   41,   -1,   -1,   44,   -1,
   -1,  118,  119,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   93,   94,   58,  130,   60,   61,   62,   63,   -1,  280,
   -1,   -1,   -1,  284,  285,   -1,   -1,   -1,  280,    0,
   -1,   -1,  284,  285,  286,  287,  288,  289,  290,  291,
   -1,  124,  125,   -1,   -1,   -1,   -1,   93,   94,   -1,
   -1,   -1,   -1,   -1,   -1,  280,    0,   -1,   -1,  284,
  285,  286,  287,  288,  289,  290,  291,   38,   -1,   -1,
   41,  188,   -1,   44,    0,   -1,   -1,   -1,  124,  125,
   -1,   -1,   -1,   -1,   -1,  202,   -1,   58,   -1,   60,
   61,   62,   63,   -1,   38,   -1,   -1,   41,   -1,   -1,
   44,  280,    0,   -1,   -1,  284,  285,  286,  287,  288,
  289,   -1,   38,   -1,   58,   41,  233,   61,   44,   63,
   -1,    0,   93,   94,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   58,  276,  277,   61,   -1,   63,   -1,   -1,
   38,   -1,   40,   41,   42,   -1,   44,   -1,   -1,   93,
   94,   -1,   -1,  124,  125,   -1,   -1,   -1,   -1,   38,
   -1,   40,   41,   42,   62,   44,   64,   93,   94,    0,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
  124,  125,   -1,   62,   -1,   64,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   91,   -1,   -1,   -1,  280,  124,  125,
   -1,  284,  285,  286,  287,  288,  289,   38,   -1,   40,
   41,   42,   91,   44,    0,   -1,   -1,   -1,   -1,   -1,
   -1,    0,   -1,   -1,   -1,   -1,   -1,  125,    0,   -1,
   -1,   62,   -1,   64,  280,   -1,   -1,   -1,  284,  285,
  286,  287,  288,  289,   -1,   -1,  125,   -1,   -1,   -1,
   -1,   -1,   38,   -1,   40,   41,   42,   -1,   44,   38,
   91,   40,   41,   42,   -1,   44,   38,   -1,   40,   41,
   42,   -1,   44,   -1,   -1,   -1,   62,   -1,   64,   -1,
   -1,   -1,   -1,   62,  261,   64,  263,  264,  265,  266,
   62,  268,   64,  270,  125,  272,  273,  274,  275,  276,
  277,  278,   -1,   -1,   -1,   91,   -1,   -1,   -1,  280,
   -1,   -1,   91,  284,  285,  286,  287,  288,  289,   91,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  280,   -1,   -1,  125,
  284,  285,  286,  287,   -1,   -1,  125,   -1,   -1,   -1,
   -1,   -1,   -1,  125,  280,   -1,   -1,   -1,  284,  285,
    0,   -1,   -1,  261,   -1,  263,  264,  265,  266,   -1,
  268,  269,  270,   -1,  272,  273,  274,  275,  276,  277,
  278,   -1,  261,   -1,  263,  264,  265,  266,   -1,  268,
  269,  270,   -1,  272,  273,  274,  275,  276,   38,  278,
   40,   41,   42,   -1,   44,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,    0,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   62,   -1,   64,   -1,   -1,   -1,   -1,    0,
  261,   -1,  263,  264,  265,  266,   -1,  268,  269,  270,
   -1,  272,  273,  274,  275,   -1,  277,  278,   -1,   -1,
   38,   91,   40,   41,   42,   -1,   44,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,    0,   -1,   -1,   38,   -1,   40,
   41,   42,   -1,   44,   62,  261,   64,  263,  264,  265,
  266,    0,  268,  269,  270,  125,  272,  273,  274,  275,
  269,   62,  278,   64,    0,   42,   -1,  276,  277,   -1,
   -1,   -1,   38,   91,   40,   41,   42,   -1,   44,    0,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   38,
   91,   40,   41,   42,    0,   44,   62,   -1,   64,   -1,
   -1,   -1,   38,   -1,   40,   41,   42,  125,   44,    0,
   -1,   -1,   -1,   62,   -1,   64,   -1,   38,   -1,   40,
   41,   42,    0,   44,  125,   91,   62,   -1,   64,   -1,
   -1,   -1,   38,   -1,   40,   41,   42,   -1,   44,    0,
   -1,   62,   91,   64,   -1,   -1,   -1,   38,   -1,   40,
   41,   42,    0,   44,   -1,   91,   62,   -1,   64,  125,
   38,   -1,   40,   41,   42,   -1,   44,   -1,   -1,   -1,
   91,   62,   -1,   64,   -1,   -1,  125,   38,   -1,   40,
   41,   42,   -1,   44,   62,   91,   64,   -1,   -1,  125,
   38,    0,   40,   41,   42,   -1,   44,   -1,   -1,  269,
   91,   62,   -1,   64,  125,   -1,  276,  277,   -1,   -1,
   -1,   -1,   -1,   91,   62,   33,   64,   -1,   -1,  125,
   38,   -1,   40,   -1,   42,   -1,   -1,   45,   -1,   38,
   91,   40,   41,   42,  125,   44,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   91,   -1,   -1,   -1,  125,   -1,   -1,
   -1,  269,   -1,   62,   -1,   64,   -1,   -1,  276,  277,
   33,   -1,   -1,   -1,  125,   38,   -1,   40,  269,   42,
   -1,   -1,   45,   -1,   -1,  276,  277,  125,   -1,   -1,
   -1,   -1,   91,  260,  261,  262,  263,  264,  265,  266,
   -1,  268,   -1,  270,   -1,  272,  273,  274,  275,  276,
  277,  278,   33,  269,   -1,  123,   -1,   -1,  126,   40,
  276,  277,   -1,   -1,   -1,   -1,  125,   -1,   -1,  296,
  269,   -1,   -1,   -1,   -1,   -1,   -1,  276,  277,   -1,
   -1,   -1,   -1,  269,   -1,   -1,   -1,   -1,   -1,   -1,
  276,  277,   -1,   -1,   -1,   -1,   -1,   -1,  269,   -1,
  123,   -1,   -1,  126,   -1,  276,  277,   -1,   -1,   -1,
   -1,   -1,   -1,  269,   -1,   -1,   -1,   -1,   -1,   -1,
  276,  277,   -1,   -1,   -1,   -1,   -1,   -1,  269,   -1,
   -1,   -1,   -1,   -1,   -1,  276,  277,   -1,   -1,   -1,
   -1,  269,  123,   -1,   -1,  126,   -1,   -1,  276,  277,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  269,   -1,
   -1,   -1,   -1,   -1,   -1,  276,  277,   -1,   -1,   -1,
   -1,  269,   -1,   -1,   -1,   -1,   -1,   -1,  276,  277,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  257,
  258,  259,  260,  261,  262,  263,  264,  265,  266,  267,
  268,  269,  270,   -1,  272,  273,  274,  275,  276,  277,
  278,  279,   -1,  281,  282,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  293,  294,   -1,  296,  297,
   -1,   -1,   -1,   -1,  257,  258,  259,  260,  261,  262,
  263,  264,  265,  266,  267,  268,  269,  270,   -1,  272,
  273,  274,  275,  276,  277,  278,  279,   -1,  281,  282,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
  293,  294,   -1,  296,  297,   -1,  257,  258,  259,  260,
  261,  262,  263,  264,  265,  266,  267,  268,  269,  270,
   -1,  272,  273,  274,  275,  276,  277,  278,  279,   -1,
  281,  282,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  293,  294,   -1,  296,  297,   37,   38,   -1,
   40,   -1,   42,   43,   -1,   45,   46,   47,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   58,   -1,
   60,   61,   62,   63,   64,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   37,   38,   -1,   40,   -1,   42,   43,   -1,
   45,   46,   47,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   91,   -1,   -1,   94,   60,   61,   62,   63,   64,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   37,   38,   -1,
   40,   -1,   42,   43,   42,   45,   46,   47,   -1,   -1,
   -1,   -1,   -1,   -1,  124,   -1,   91,   -1,   -1,   94,
   60,   -1,   62,   63,   64,   37,   38,   -1,   40,   -1,
   42,   43,   -1,   45,   46,   47,   37,   38,   -1,   40,
   -1,   42,   43,   -1,   45,   46,   47,   -1,   60,  124,
   62,   91,   64,   -1,   94,   -1,   -1,   -1,   -1,   60,
   -1,   62,   -1,   64,   37,   38,   -1,   40,   -1,   42,
   43,   -1,   45,   46,   47,   41,   -1,   -1,   -1,   91,
   -1,   -1,   94,   -1,  124,   -1,   -1,   60,   -1,   62,
   91,   64,   -1,   94,   -1,   -1,   -1,   37,   38,   -1,
   40,   -1,   42,   43,   -1,   45,   46,   47,   -1,   -1,
   -1,   -1,  124,   -1,   -1,   -1,   -1,   -1,   91,   -1,
   60,   94,   62,  124,   64,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   37,   -1,   -1,   40,   -1,   42,   43,   -1,
   45,   46,   47,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   91,   -1,   -1,   -1,   60,   -1,   62,   -1,   64,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
  280,   -1,   -1,   -1,  284,  285,  286,  287,  288,  289,
  290,  291,   -1,  293,  294,  295,   91,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  280,   -1,   -1,   -1,  284,
  285,  286,  287,  288,  289,  290,  291,   -1,  293,  294,
  295,   -1,  260,  261,  262,  263,  264,  265,  266,   -1,
  268,   -1,  270,   -1,  272,  273,  274,  275,  276,  277,
  278,   -1,   -1,   -1,  284,  285,  286,  287,  288,  289,
  290,  291,   -1,  293,  294,  295,   -1,   -1,  296,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  285,  286,  287,  288,  289,  290,  291,
   -1,  293,  294,  295,   -1,  286,  287,  288,  289,  290,
  291,   -1,  293,  294,  295,  261,   -1,  263,  264,  265,
  266,   -1,  268,   -1,  270,   -1,  272,  273,  274,  275,
  276,  277,  278,  286,  287,  288,  289,  290,  291,   -1,
  293,  294,  295,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
    0,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   11,   -1,   -1,   -1,  286,  287,  288,  289,
  290,  291,   -1,  293,  294,  295,   25,   26,   27,   28,
   29,   -1,   -1,   -1,   33,   34,   -1,   -1,   38,   -1,
   40,   41,   42,   42,   44,   -1,   -1,   -1,   -1,   -1,
   -1,  286,  287,  288,  289,  290,  291,   -1,  293,  294,
  295,   -1,   62,   -1,   64,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   91,   -1,   -1,   -1,   94,   95,   96,   97,   98,
   99,  100,  101,  102,  103,  104,  105,  106,  107,  108,
  109,  110,  111,  112,  113,  114,  115,   -1,   -1,   -1,
   -1,   -1,   -1,  122,   -1,  125,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  150,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  174,   -1,   -1,  177,   -1,
   -1,   -1,  181,   -1,   -1,  184,  185,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,  203,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  211,
};
#define YYFINAL 36
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#define YYMAXTOKEN 297
#define YYUNDFTOKEN 329
#define YYTRANSLATE(a) ((a) > YYMAXTOKEN ? YYUNDFTOKEN : (a))
#if YYDEBUG
static const char *const yyname[] = {

"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
"'!'",0,0,0,"'%'","'&'",0,"'('","')'","'*'","'+'","','","'-'","'.'","'/'",0,0,0,
0,0,0,0,0,0,0,"':'",0,"'<'","'='","'>'","'?'","'@'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,"'['",0,"']'","'^'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,"'{'","'|'","'}'","'~'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"INT","FLOAT",
"STRING","NAME","TYPENAME","NAME_OR_INT","STRUCT","CLASS","UNION","ENUM",
"SIZEOF","UNSIGNED","COLONCOLON","TEMPLATE","ERROR","SIGNED_KEYWORD","LONG",
"SHORT","INT_KEYWORD","CONST_KEYWORD","VOLATILE_KEYWORD","DOUBLE_KEYWORD",
"VARIABLE","ASSIGN_MODIFY","TRUEKEYWORD","FALSEKEYWORD","ABOVE_COMMA","OROR",
"ANDAND","EQUAL","NOTEQUAL","LEQ","GEQ","LSH","RSH","UNARY","INCREMENT",
"DECREMENT","ARROW","BLOCKNAME","FILENAME",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,"illegal-symbol",
};
static const char *const yyrule[] = {
"$accept : start",
"start : exp1",
"start : type_exp",
"type_exp : type",
"exp1 : exp",
"exp1 : exp1 ',' exp",
"exp : '*' exp",
"exp : '&' exp",
"exp : '-' exp",
"exp : '!' exp",
"exp : '~' exp",
"exp : INCREMENT exp",
"exp : DECREMENT exp",
"exp : exp INCREMENT",
"exp : exp DECREMENT",
"exp : SIZEOF exp",
"exp : exp ARROW name",
"exp : exp ARROW qualified_name",
"exp : exp ARROW '*' exp",
"exp : exp '.' name",
"exp : exp '.' qualified_name",
"exp : exp '.' '*' exp",
"exp : exp '[' exp1 ']'",
"$$1 :",
"exp : exp '(' $$1 arglist ')'",
"lcurly : '{'",
"arglist :",
"arglist : exp",
"arglist : arglist ',' exp",
"rcurly : '}'",
"exp : lcurly arglist rcurly",
"exp : lcurly type rcurly exp",
"exp : '(' type ')' exp",
"exp : '(' exp1 ')'",
"exp : exp '@' exp",
"exp : exp '*' exp",
"exp : exp '/' exp",
"exp : exp '%' exp",
"exp : exp '+' exp",
"exp : exp '-' exp",
"exp : exp LSH exp",
"exp : exp RSH exp",
"exp : exp EQUAL exp",
"exp : exp NOTEQUAL exp",
"exp : exp LEQ exp",
"exp : exp GEQ exp",
"exp : exp '<' exp",
"exp : exp '>' exp",
"exp : exp '&' exp",
"exp : exp '^' exp",
"exp : exp '|' exp",
"exp : exp ANDAND exp",
"exp : exp OROR exp",
"exp : exp '?' exp ':' exp",
"exp : exp '=' exp",
"exp : exp ASSIGN_MODIFY exp",
"exp : INT",
"exp : NAME_OR_INT",
"exp : FLOAT",
"exp : variable",
"exp : VARIABLE",
"exp : SIZEOF '(' type ')'",
"exp : STRING",
"exp : TRUEKEYWORD",
"exp : FALSEKEYWORD",
"block : BLOCKNAME",
"block : FILENAME",
"block : block COLONCOLON name",
"variable : block COLONCOLON name",
"qualified_name : typebase COLONCOLON name",
"qualified_name : typebase COLONCOLON '~' name",
"variable : qualified_name",
"variable : COLONCOLON name",
"variable : name_not_typename",
"space_identifier : '@' NAME",
"const_or_volatile : const_or_volatile_noopt",
"const_or_volatile :",
"cv_with_space_id : const_or_volatile space_identifier const_or_volatile",
"const_or_volatile_or_space_identifier_noopt : cv_with_space_id",
"const_or_volatile_or_space_identifier_noopt : const_or_volatile_noopt",
"const_or_volatile_or_space_identifier : const_or_volatile_or_space_identifier_noopt",
"const_or_volatile_or_space_identifier :",
"abs_decl : '*'",
"abs_decl : '*' abs_decl",
"abs_decl : '&'",
"abs_decl : '&' abs_decl",
"abs_decl : direct_abs_decl",
"direct_abs_decl : '(' abs_decl ')'",
"direct_abs_decl : direct_abs_decl array_mod",
"direct_abs_decl : array_mod",
"direct_abs_decl : direct_abs_decl func_mod",
"direct_abs_decl : func_mod",
"array_mod : '[' ']'",
"array_mod : '[' INT ']'",
"func_mod : '(' ')'",
"func_mod : '(' nonempty_typelist ')'",
"type : ptype",
"type : typebase COLONCOLON '*'",
"typebase : TYPENAME",
"typebase : INT_KEYWORD",
"typebase : LONG",
"typebase : SHORT",
"typebase : LONG INT_KEYWORD",
"typebase : LONG SIGNED_KEYWORD INT_KEYWORD",
"typebase : LONG SIGNED_KEYWORD",
"typebase : SIGNED_KEYWORD LONG INT_KEYWORD",
"typebase : UNSIGNED LONG INT_KEYWORD",
"typebase : LONG UNSIGNED INT_KEYWORD",
"typebase : LONG UNSIGNED",
"typebase : LONG LONG",
"typebase : LONG LONG INT_KEYWORD",
"typebase : LONG LONG SIGNED_KEYWORD INT_KEYWORD",
"typebase : LONG LONG SIGNED_KEYWORD",
"typebase : SIGNED_KEYWORD LONG LONG",
"typebase : SIGNED_KEYWORD LONG LONG INT_KEYWORD",
"typebase : UNSIGNED LONG LONG",
"typebase : UNSIGNED LONG LONG INT_KEYWORD",
"typebase : LONG LONG UNSIGNED",
"typebase : LONG LONG UNSIGNED INT_KEYWORD",
"typebase : SHORT INT_KEYWORD",
"typebase : SHORT SIGNED_KEYWORD INT_KEYWORD",
"typebase : SHORT SIGNED_KEYWORD",
"typebase : UNSIGNED SHORT INT_KEYWORD",
"typebase : SHORT UNSIGNED",
"typebase : SHORT UNSIGNED INT_KEYWORD",
"typebase : DOUBLE_KEYWORD",
"typebase : LONG DOUBLE_KEYWORD",
"typebase : STRUCT name",
"typebase : CLASS name",
"typebase : UNION name",
"typebase : ENUM name",
"typebase : UNSIGNED typename",
"typebase : UNSIGNED",
"typebase : SIGNED_KEYWORD typename",
"typebase : SIGNED_KEYWORD",
"typebase : TEMPLATE name '<' type '>'",
"typebase : const_or_volatile_or_space_identifier_noopt typebase",
"typebase : typebase const_or_volatile_or_space_identifier_noopt",
"typebase : qualified_type",
"qualified_type : typebase COLONCOLON name",
"typename : TYPENAME",
"typename : INT_KEYWORD",
"typename : LONG",
"typename : SHORT",
"nonempty_typelist : type",
"nonempty_typelist : nonempty_typelist ',' type",
"ptype : typebase",
"ptype : ptype const_or_volatile_or_space_identifier abs_decl const_or_volatile_or_space_identifier",
"const_and_volatile : CONST_KEYWORD VOLATILE_KEYWORD",
"const_and_volatile : VOLATILE_KEYWORD CONST_KEYWORD",
"const_or_volatile_noopt : const_and_volatile",
"const_or_volatile_noopt : CONST_KEYWORD",
"const_or_volatile_noopt : VOLATILE_KEYWORD",
"name : NAME",
"name : BLOCKNAME",
"name : TYPENAME",
"name : NAME_OR_INT",
"name_not_typename : NAME",
"name_not_typename : BLOCKNAME",

};
#endif

int      yydebug;
int      yynerrs;

int      yyerrflag;
int      yychar;
YYSTYPE  yyval;
YYSTYPE  yylval;

/* define the initial stack-sizes */
#ifdef YYSTACKSIZE
#undef YYMAXDEPTH
#define YYMAXDEPTH  YYSTACKSIZE
#else
#ifdef YYMAXDEPTH
#define YYSTACKSIZE YYMAXDEPTH
#else
#define YYSTACKSIZE 10000
#define YYMAXDEPTH  10000
#endif
#endif

#define YYINITSTACKSIZE 200

typedef struct {
    unsigned stacksize;
    YYINT    *s_base;
    YYINT    *s_mark;
    YYINT    *s_last;
    YYSTYPE  *l_base;
    YYSTYPE  *l_mark;
} YYSTACKDATA;
/* variables for the parser stack */
static YYSTACKDATA yystack;
#line 1038 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"

/* Take care of parsing a number (anything that starts with a digit).
   Set yylval and return the token type; update lexptr.
   LEN is the number of characters in it.  */

/*** Needs some error checking for the float case ***/

static int
parse_number (p, len, parsed_float, putithere)
     char *p;
     int len;
     int parsed_float;
     YYSTYPE *putithere;
{
  /* FIXME: Shouldn't these be unsigned?  We don't deal with negative values
     here, and we do kind of silly things like cast to unsigned.  */
  LONGEST n = 0;
  LONGEST prevn = 0;
  ULONGEST un;

  int i = 0;
  int c;
  int base = input_radix;
  int unsigned_p = 0;

  /* Number of "L" suffixes encountered.  */
  int long_p = 0;

  /* We have found a "L" or "U" suffix.  */
  int found_suffix = 0;

  ULONGEST high_bit;
  struct type *signed_type;
  struct type *unsigned_type;

  if (parsed_float)
    {
      /* It's a float since it contains a point or an exponent.  */
      char c;
      int num = 0;	/* number of tokens scanned by scanf */
      char saved_char = p[len];

      p[len] = 0;	/* null-terminate the token */
      if (sizeof (putithere->typed_val_float.dval) <= sizeof (float))
	num = sscanf (p, "%g%c", (float *) &putithere->typed_val_float.dval,&c);
      else if (sizeof (putithere->typed_val_float.dval) <= sizeof (double))
	num = sscanf (p, "%lg%c", (double *) &putithere->typed_val_float.dval,&c);
      else
	{
#ifdef SCANF_HAS_LONG_DOUBLE
	  num = sscanf (p, "%Lg%c", &putithere->typed_val_float.dval,&c);
#else
	  /* Scan it into a double, then assign it to the long double.
	     This at least wins with values representable in the range
	     of doubles. */
	  double temp;
	  num = sscanf (p, "%lg%c", &temp,&c);
	  putithere->typed_val_float.dval = temp;
#endif
	}
      p[len] = saved_char;	/* restore the input stream */
      if (num != 1) 		/* check scanf found ONLY a float ... */
	return ERROR;
      /* See if it has `f' or `l' suffix (float or long double).  */

      c = tolower (p[len - 1]);

      if (c == 'f')
	putithere->typed_val_float.type = builtin_type_float;
      else if (c == 'l')
	putithere->typed_val_float.type = builtin_type_long_double;
      else if (isdigit (c) || c == '.')
	putithere->typed_val_float.type = builtin_type_double;
      else
	return ERROR;

      return FLOAT;
    }

  /* Handle base-switching prefixes 0x, 0t, 0d, 0 */
  if (p[0] == '0')
    switch (p[1])
      {
      case 'x':
      case 'X':
	if (len >= 3)
	  {
	    p += 2;
	    base = 16;
	    len -= 2;
	  }
	break;

      case 't':
      case 'T':
      case 'd':
      case 'D':
	if (len >= 3)
	  {
	    p += 2;
	    base = 10;
	    len -= 2;
	  }
	break;

      default:
	base = 8;
	break;
      }

  while (len-- > 0)
    {
      c = *p++;
      if (c >= 'A' && c <= 'Z')
	c += 'a' - 'A';
      if (c != 'l' && c != 'u')
	n *= base;
      if (c >= '0' && c <= '9')
	{
	  if (found_suffix)
	    return ERROR;
	  n += i = c - '0';
	}
      else
	{
	  if (base > 10 && c >= 'a' && c <= 'f')
	    {
	      if (found_suffix)
		return ERROR;
	      n += i = c - 'a' + 10;
	    }
	  else if (c == 'l')
	    {
	      ++long_p;
	      found_suffix = 1;
	    }
	  else if (c == 'u')
	    {
	      unsigned_p = 1;
	      found_suffix = 1;
	    }
	  else
	    return ERROR;	/* Char not a digit */
	}
      if (i >= base)
	return ERROR;		/* Invalid digit in this base */

      /* Portably test for overflow (only works for nonzero values, so make
	 a second check for zero).  FIXME: Can't we just make n and prevn
	 unsigned and avoid this?  */
      if (c != 'l' && c != 'u' && (prevn >= n) && n != 0)
	unsigned_p = 1;		/* Try something unsigned */

      /* Portably test for unsigned overflow.
	 FIXME: This check is wrong; for example it doesn't find overflow
	 on 0x123456789 when LONGEST is 32 bits.  */
      if (c != 'l' && c != 'u' && n != 0)
	{	
	  if ((unsigned_p && (ULONGEST) prevn >= (ULONGEST) n))
	    error ("Numeric constant too large.");
	}
      prevn = n;
    }

  /* An integer constant is an int, a long, or a long long.  An L
     suffix forces it to be long; an LL suffix forces it to be long
     long.  If not forced to a larger size, it gets the first type of
     the above that it fits in.  To figure out whether it fits, we
     shift it right and see whether anything remains.  Note that we
     can't shift sizeof (LONGEST) * HOST_CHAR_BIT bits or more in one
     operation, because many compilers will warn about such a shift
     (which always produces a zero result).  Sometimes TARGET_INT_BIT
     or TARGET_LONG_BIT will be that big, sometimes not.  To deal with
     the case where it is we just always shift the value more than
     once, with fewer bits each time.  */

  un = (ULONGEST)n >> 2;
  if (long_p == 0
      && (un >> (TARGET_INT_BIT - 2)) == 0)
    {
      high_bit = ((ULONGEST)1) << (TARGET_INT_BIT-1);

      /* A large decimal (not hex or octal) constant (between INT_MAX
	 and UINT_MAX) is a long or unsigned long, according to ANSI,
	 never an unsigned int, but this code treats it as unsigned
	 int.  This probably should be fixed.  GCC gives a warning on
	 such constants.  */

      unsigned_type = builtin_type_unsigned_int;
      signed_type = builtin_type_int;
    }
  else if (long_p <= 1
	   && (un >> (TARGET_LONG_BIT - 2)) == 0)
    {
      high_bit = ((ULONGEST)1) << (TARGET_LONG_BIT-1);
      unsigned_type = builtin_type_unsigned_long;
      signed_type = builtin_type_long;
    }
  else
    {
      int shift;
      if (sizeof (ULONGEST) * HOST_CHAR_BIT < TARGET_LONG_LONG_BIT)
	/* A long long does not fit in a LONGEST.  */
	shift = (sizeof (ULONGEST) * HOST_CHAR_BIT - 1);
      else
	shift = (TARGET_LONG_LONG_BIT - 1);
      high_bit = (ULONGEST) 1 << shift;
      unsigned_type = builtin_type_unsigned_long_long;
      signed_type = builtin_type_long_long;
    }

   putithere->typed_val_int.val = n;

   /* If the high bit of the worked out type is set then this number
      has to be unsigned. */

   if (unsigned_p || (n & high_bit)) 
     {
       putithere->typed_val_int.type = unsigned_type;
     }
   else 
     {
       putithere->typed_val_int.type = signed_type;
     }

   return INT;
}

struct token
{
  char *operator;
  int token;
  enum exp_opcode opcode;
};

static const struct token tokentab3[] =
  {
    {">>=", ASSIGN_MODIFY, BINOP_RSH},
    {"<<=", ASSIGN_MODIFY, BINOP_LSH}
  };

static const struct token tokentab2[] =
  {
    {"+=", ASSIGN_MODIFY, BINOP_ADD},
    {"-=", ASSIGN_MODIFY, BINOP_SUB},
    {"*=", ASSIGN_MODIFY, BINOP_MUL},
    {"/=", ASSIGN_MODIFY, BINOP_DIV},
    {"%=", ASSIGN_MODIFY, BINOP_REM},
    {"|=", ASSIGN_MODIFY, BINOP_BITWISE_IOR},
    {"&=", ASSIGN_MODIFY, BINOP_BITWISE_AND},
    {"^=", ASSIGN_MODIFY, BINOP_BITWISE_XOR},
    {"++", INCREMENT, BINOP_END},
    {"--", DECREMENT, BINOP_END},
    {"->", ARROW, BINOP_END},
    {"&&", ANDAND, BINOP_END},
    {"||", OROR, BINOP_END},
    {"::", COLONCOLON, BINOP_END},
    {"<<", LSH, BINOP_END},
    {">>", RSH, BINOP_END},
    {"==", EQUAL, BINOP_END},
    {"!=", NOTEQUAL, BINOP_END},
    {"<=", LEQ, BINOP_END},
    {">=", GEQ, BINOP_END}
  };

/* Read one token, getting characters through lexptr.  */

static int
yylex ()
{
  int c;
  int namelen;
  unsigned int i;
  char *tokstart;
  char *tokptr;
  int tempbufindex;
  static char *tempbuf;
  static int tempbufsize;
  struct symbol * sym_class = NULL;
  char * token_string = NULL;
  int class_prefix = 0;
  int unquoted_expr;
   
 retry:

  /* Check if this is a macro invocation that we need to expand.  */
  if (! scanning_macro_expansion ())
    {
      char *expanded = macro_expand_next (&lexptr,
                                          expression_macro_lookup_func,
                                          expression_macro_lookup_baton);

      if (expanded)
        scan_macro_expansion (expanded);
    }

  prev_lexptr = lexptr;
  unquoted_expr = 1;

  tokstart = lexptr;
  /* See if it is a special token of length 3.  */
  for (i = 0; i < sizeof tokentab3 / sizeof tokentab3[0]; i++)
    if (strncmp (tokstart, tokentab3[i].operator, 3) == 0)
      {
	lexptr += 3;
	yylval.opcode = tokentab3[i].opcode;
	return tokentab3[i].token;
      }

  /* See if it is a special token of length 2.  */
  for (i = 0; i < sizeof tokentab2 / sizeof tokentab2[0]; i++)
    if (strncmp (tokstart, tokentab2[i].operator, 2) == 0)
      {
	lexptr += 2;
	yylval.opcode = tokentab2[i].opcode;
	return tokentab2[i].token;
      }

  switch (c = *tokstart)
    {
    case 0:
      /* If we were just scanning the result of a macro expansion,
         then we need to resume scanning the original text.
         Otherwise, we were already scanning the original text, and
         we're really done.  */
      if (scanning_macro_expansion ())
        {
          finished_macro_expansion ();
          goto retry;
        }
      else
        return 0;

    case ' ':
    case '\t':
    case '\n':
      lexptr++;
      goto retry;

    case '\'':
      /* We either have a character constant ('0' or '\177' for example)
	 or we have a quoted symbol reference ('foo(int,int)' in C++
	 for example). */
      lexptr++;
      c = *lexptr++;
      if (c == '\\')
	c = parse_escape (&lexptr);
      else if (c == '\'')
	error ("Empty character constant.");
      else if (! host_char_to_target (c, &c))
        {
          int toklen = lexptr - tokstart + 1;
          char *tok = alloca (toklen + 1);
          memcpy (tok, tokstart, toklen);
          tok[toklen] = '\0';
          error ("There is no character corresponding to %s in the target "
                 "character set `%s'.", tok, target_charset ());
        }

      yylval.typed_val_int.val = c;
      yylval.typed_val_int.type = builtin_type_char;

      c = *lexptr++;
      if (c != '\'')
	{
	  namelen = skip_quoted (tokstart) - tokstart;
	  if (namelen > 2)
	    {
	      lexptr = tokstart + namelen;
              unquoted_expr = 0;
	      if (lexptr[-1] != '\'')
		error ("Unmatched single quote.");
	      namelen -= 2;
	      tokstart++;
	      goto tryname;
	    }
	  error ("Invalid character constant.");
	}
      return INT;

    case '(':
      paren_depth++;
      lexptr++;
      return c;

    case ')':
      if (paren_depth == 0)
	return 0;
      paren_depth--;
      lexptr++;
      return c;

    case ',':
      if (comma_terminates
          && paren_depth == 0
          && ! scanning_macro_expansion ())
	return 0;
      lexptr++;
      return c;

    case '.':
      /* Might be a floating point number.  */
      if (lexptr[1] < '0' || lexptr[1] > '9')
	goto symbol;		/* Nope, must be a symbol. */
      /* FALL THRU into number case.  */

    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
      {
	/* It's a number.  */
	int got_dot = 0, got_e = 0, toktype;
	char *p = tokstart;
	int hex = input_radix > 10;

	if (c == '0' && (p[1] == 'x' || p[1] == 'X'))
	  {
	    p += 2;
	    hex = 1;
	  }
	else if (c == '0' && (p[1]=='t' || p[1]=='T' || p[1]=='d' || p[1]=='D'))
	  {
	    p += 2;
	    hex = 0;
	  }

	for (;; ++p)
	  {
	    /* This test includes !hex because 'e' is a valid hex digit
	       and thus does not indicate a floating point number when
	       the radix is hex.  */
	    if (!hex && !got_e && (*p == 'e' || *p == 'E'))
	      got_dot = got_e = 1;
	    /* This test does not include !hex, because a '.' always indicates
	       a decimal floating point number regardless of the radix.  */
	    else if (!got_dot && *p == '.')
	      got_dot = 1;
	    else if (got_e && (p[-1] == 'e' || p[-1] == 'E')
		     && (*p == '-' || *p == '+'))
	      /* This is the sign of the exponent, not the end of the
		 number.  */
	      continue;
	    /* We will take any letters or digits.  parse_number will
	       complain if past the radix, or if L or U are not final.  */
	    else if ((*p < '0' || *p > '9')
		     && ((*p < 'a' || *p > 'z')
				  && (*p < 'A' || *p > 'Z')))
	      break;
	  }
	toktype = parse_number (tokstart, p - tokstart, got_dot|got_e, &yylval);
        if (toktype == ERROR)
	  {
	    char *err_copy = (char *) alloca (p - tokstart + 1);

	    memcpy (err_copy, tokstart, p - tokstart);
	    err_copy[p - tokstart] = 0;
	    error ("Invalid number \"%s\".", err_copy);
	  }
	lexptr = p;
	return toktype;
      }

    case '+':
    case '-':
    case '*':
    case '/':
    case '%':
    case '|':
    case '&':
    case '^':
    case '~':
    case '!':
    case '@':
    case '<':
    case '>':
    case '[':
    case ']':
    case '?':
    case ':':
    case '=':
    case '{':
    case '}':
    symbol:
      lexptr++;
      return c;

    case '"':

      /* Build the gdb internal form of the input string in tempbuf,
	 translating any standard C escape forms seen.  Note that the
	 buffer is null byte terminated *only* for the convenience of
	 debugging gdb itself and printing the buffer contents when
	 the buffer contains no embedded nulls.  Gdb does not depend
	 upon the buffer being null byte terminated, it uses the length
	 string instead.  This allows gdb to handle C strings (as well
	 as strings in other languages) with embedded null bytes */

      tokptr = ++tokstart;
      tempbufindex = 0;

      do {
        char *char_start_pos = tokptr;

	/* Grow the static temp buffer if necessary, including allocating
	   the first one on demand. */
	if (tempbufindex + 1 >= tempbufsize)
	  {
	    tempbuf = (char *) realloc (tempbuf, tempbufsize += 64);
	  }
	switch (*tokptr)
	  {
	  case '\0':
	  case '"':
	    /* Do nothing, loop will terminate. */
	    break;
	  case '\\':
	    tokptr++;
	    c = parse_escape (&tokptr);
	    if (c == -1)
	      {
		continue;
	      }
	    tempbuf[tempbufindex++] = c;
	    break;
	  default:
	    c = *tokptr++;
            if (! host_char_to_target (c, &c))
              {
                int len = tokptr - char_start_pos;
                char *copy = alloca (len + 1);
                memcpy (copy, char_start_pos, len);
                copy[len] = '\0';

                error ("There is no character corresponding to `%s' "
                       "in the target character set `%s'.",
                       copy, target_charset ());
              }
            tempbuf[tempbufindex++] = c;
	    break;
	  }
      } while ((*tokptr != '"') && (*tokptr != '\0'));
      if (*tokptr++ != '"')
	{
	  error ("Unterminated string in expression.");
	}
      tempbuf[tempbufindex] = '\0';	/* See note above */
      yylval.sval.ptr = tempbuf;
      yylval.sval.length = tempbufindex;
      lexptr = tokptr;
      return (STRING);
    }

  if (!(c == '_' || c == '$'
	|| (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')))
    /* We must have come across a bad character (e.g. ';').  */
    error ("Invalid character '%c' in expression.", c);

  /* It's a name.  See how long it is.  */
  namelen = 0;
  for (c = tokstart[namelen];
       (c == '_' || c == '$' || (c >= '0' && c <= '9')
	|| (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '<');)
    {
      /* Template parameter lists are part of the name.
	 FIXME: This mishandles `print $a<4&&$a>3'.  */

      if (c == '<')
	{ 
               /* Scan ahead to get rest of the template specification.  Note
                  that we look ahead only when the '<' adjoins non-whitespace
                  characters; for comparison expressions, e.g. "a < b > c",
                  there must be spaces before the '<', etc. */
               
               char * p = find_template_name_end (tokstart + namelen);
               if (p)
                 namelen = p - tokstart;
               break;
	}
      c = tokstart[++namelen];
    }

  /* The token "if" terminates the expression and is NOT removed from
     the input stream.  It doesn't count if it appears in the
     expansion of a macro.  */
  if (namelen == 2
      && tokstart[0] == 'i'
      && tokstart[1] == 'f'
      && ! scanning_macro_expansion ())
    {
      return 0;
    }

  lexptr += namelen;

  tryname:

  /* Catch specific keywords.  Should be done with a data structure.  */
  switch (namelen)
    {
    case 8:
      if (strncmp (tokstart, "unsigned", 8) == 0)
	return UNSIGNED;
      if (current_language->la_language == language_cplus
	  && strncmp (tokstart, "template", 8) == 0)
	return TEMPLATE;
      if (strncmp (tokstart, "volatile", 8) == 0)
	return VOLATILE_KEYWORD;
      break;
    case 6:
      if (strncmp (tokstart, "struct", 6) == 0)
	return STRUCT;
      if (strncmp (tokstart, "signed", 6) == 0)
	return SIGNED_KEYWORD;
      if (strncmp (tokstart, "sizeof", 6) == 0)
	return SIZEOF;
      if (strncmp (tokstart, "double", 6) == 0)
	return DOUBLE_KEYWORD;
      break;
    case 5:
      if (current_language->la_language == language_cplus)
        {
          if (strncmp (tokstart, "false", 5) == 0)
            return FALSEKEYWORD;
          if (strncmp (tokstart, "class", 5) == 0)
            return CLASS;
        }
      if (strncmp (tokstart, "union", 5) == 0)
	return UNION;
      if (strncmp (tokstart, "short", 5) == 0)
	return SHORT;
      if (strncmp (tokstart, "const", 5) == 0)
	return CONST_KEYWORD;
      break;
    case 4:
      if (strncmp (tokstart, "enum", 4) == 0)
	return ENUM;
      if (strncmp (tokstart, "long", 4) == 0)
	return LONG;
      if (current_language->la_language == language_cplus)
          {
            if (strncmp (tokstart, "true", 4) == 0)
              return TRUEKEYWORD;
          }
      break;
    case 3:
      if (strncmp (tokstart, "int", 3) == 0)
	return INT_KEYWORD;
      break;
    default:
      break;
    }

  yylval.sval.ptr = tokstart;
  yylval.sval.length = namelen;

  if (*tokstart == '$')
    {
      write_dollar_variable (yylval.sval);
      return VARIABLE;
    }
  
  /* Look ahead and see if we can consume more of the input
     string to get a reasonable class/namespace spec or a
     fully-qualified name.  This is a kludge to get around the
     HP aCC compiler's generation of symbol names with embedded
     colons for namespace and nested classes. */

  /* NOTE: carlton/2003-09-24: I don't entirely understand the
     HP-specific code, either here or in linespec.  Having said that,
     I suspect that we're actually moving towards their model: we want
     symbols whose names are fully qualified, which matches the
     description above.  */
  if (unquoted_expr)
    {
      /* Only do it if not inside single quotes */ 
      sym_class = parse_nested_classes_for_hpacc (yylval.sval.ptr, yylval.sval.length,
                                                  &token_string, &class_prefix, &lexptr);
      if (sym_class)
        {
          /* Replace the current token with the bigger one we found */ 
          yylval.sval.ptr = token_string;
          yylval.sval.length = strlen (token_string);
        }
    }
  
  /* Use token-type BLOCKNAME for symbols that happen to be defined as
     functions or symtabs.  If this is not so, then ...
     Use token-type TYPENAME for symbols that happen to be defined
     currently as names of types; NAME for other symbols.
     The caller is not constrained to care about the distinction.  */
  {
    char *tmp = copy_name (yylval.sval);
    struct symbol *sym;
    int is_a_field_of_this = 0;
    int hextype;

    sym = lookup_symbol (tmp, expression_context_block,
			 VAR_DOMAIN,
			 current_language->la_language == language_cplus
			 ? &is_a_field_of_this : (int *) NULL,
			 (struct symtab **) NULL);
    /* Call lookup_symtab, not lookup_partial_symtab, in case there are
       no psymtabs (coff, xcoff, or some future change to blow away the
       psymtabs once once symbols are read).  */
    if (sym && SYMBOL_CLASS (sym) == LOC_BLOCK)
      {
	yylval.ssym.sym = sym;
	yylval.ssym.is_a_field_of_this = is_a_field_of_this;
	return BLOCKNAME;
      }
    else if (!sym)
      {				/* See if it's a file name. */
	struct symtab *symtab;

	symtab = lookup_symtab (tmp);

	if (symtab)
	  {
	    yylval.bval = BLOCKVECTOR_BLOCK (BLOCKVECTOR (symtab), STATIC_BLOCK);
	    return FILENAME;
	  }
      }

    if (sym && SYMBOL_CLASS (sym) == LOC_TYPEDEF)
        {
	  /* NOTE: carlton/2003-09-25: There used to be code here to
	     handle nested types.  It didn't work very well.  See the
	     comment before qualified_type for more info.  */
	  yylval.tsym.type = SYMBOL_TYPE (sym);
	  return TYPENAME;
        }
    if ((yylval.tsym.type = lookup_primitive_typename (tmp)) != 0)
      return TYPENAME;

    /* Input names that aren't symbols but ARE valid hex numbers,
       when the input radix permits them, can be names or numbers
       depending on the parse.  Note we support radixes > 16 here.  */
    if (!sym && 
        ((tokstart[0] >= 'a' && tokstart[0] < 'a' + input_radix - 10) ||
         (tokstart[0] >= 'A' && tokstart[0] < 'A' + input_radix - 10)))
      {
 	YYSTYPE newlval;	/* Its value is ignored.  */
	hextype = parse_number (tokstart, namelen, 0, &newlval);
	if (hextype == INT)
	  {
	    yylval.ssym.sym = sym;
	    yylval.ssym.is_a_field_of_this = is_a_field_of_this;
	    return NAME_OR_INT;
	  }
      }

    /* Any other kind of symbol */
    yylval.ssym.sym = sym;
    yylval.ssym.is_a_field_of_this = is_a_field_of_this;
    return NAME;
  }
}

void
yyerror (msg)
     char *msg;
{
  if (prev_lexptr)
    lexptr = prev_lexptr;

  error ("A %s in expression, near `%s'.", (msg ? msg : "error"), lexptr);
}
#line 1989 "c-exp.c"

#if YYDEBUG
#include <stdio.h>		/* needed for printf */
#endif

#include <stdlib.h>	/* needed for malloc, etc */
#include <string.h>	/* needed for memset */

/* allocate initial stack or double stack size, up to YYMAXDEPTH */
static int yygrowstack(YYSTACKDATA *data)
{
    int i;
    unsigned newsize;
    YYINT *newss;
    YYSTYPE *newvs;

    if ((newsize = data->stacksize) == 0)
        newsize = YYINITSTACKSIZE;
    else if (newsize >= YYMAXDEPTH)
        return YYENOMEM;
    else if ((newsize *= 2) > YYMAXDEPTH)
        newsize = YYMAXDEPTH;

    i = (int) (data->s_mark - data->s_base);
    newss = (YYINT *)realloc(data->s_base, newsize * sizeof(*newss));
    if (newss == 0)
        return YYENOMEM;

    data->s_base = newss;
    data->s_mark = newss + i;

    newvs = (YYSTYPE *)realloc(data->l_base, newsize * sizeof(*newvs));
    if (newvs == 0)
        return YYENOMEM;

    data->l_base = newvs;
    data->l_mark = newvs + i;

    data->stacksize = newsize;
    data->s_last = data->s_base + newsize - 1;
    return 0;
}

#if YYPURE || defined(YY_NO_LEAKS)
static void yyfreestack(YYSTACKDATA *data)
{
    free(data->s_base);
    free(data->l_base);
    memset(data, 0, sizeof(*data));
}
#else
#define yyfreestack(data) /* nothing */
#endif

#define YYABORT  goto yyabort
#define YYREJECT goto yyabort
#define YYACCEPT goto yyaccept
#define YYERROR  goto yyerrlab

int
YYPARSE_DECL()
{
    int yym, yyn, yystate;
#if YYDEBUG
    const char *yys;

    if ((yys = getenv("YYDEBUG")) != 0)
    {
        yyn = *yys;
        if (yyn >= '0' && yyn <= '9')
            yydebug = yyn - '0';
    }
#endif

    yynerrs = 0;
    yyerrflag = 0;
    yychar = YYEMPTY;
    yystate = 0;

#if YYPURE
    memset(&yystack, 0, sizeof(yystack));
#endif

    if (yystack.s_base == NULL && yygrowstack(&yystack) == YYENOMEM) goto yyoverflow;
    yystack.s_mark = yystack.s_base;
    yystack.l_mark = yystack.l_base;
    yystate = 0;
    *yystack.s_mark = 0;

yyloop:
    if ((yyn = yydefred[yystate]) != 0) goto yyreduce;
    if (yychar < 0)
    {
        if ((yychar = YYLEX) < 0) yychar = YYEOF;
#if YYDEBUG
        if (yydebug)
        {
            yys = yyname[YYTRANSLATE(yychar)];
            printf("%sdebug: state %d, reading %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
    }
    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: state %d, shifting to state %d\n",
                    YYPREFIX, yystate, yytable[yyn]);
#endif
        if (yystack.s_mark >= yystack.s_last && yygrowstack(&yystack) == YYENOMEM)
        {
            goto yyoverflow;
        }
        yystate = yytable[yyn];
        *++yystack.s_mark = yytable[yyn];
        *++yystack.l_mark = yylval;
        yychar = YYEMPTY;
        if (yyerrflag > 0)  --yyerrflag;
        goto yyloop;
    }
    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
        yyn = yytable[yyn];
        goto yyreduce;
    }
    if (yyerrflag) goto yyinrecovery;

    YYERROR_CALL("syntax error");

    goto yyerrlab;

yyerrlab:
    ++yynerrs;

yyinrecovery:
    if (yyerrflag < 3)
    {
        yyerrflag = 3;
        for (;;)
        {
            if ((yyn = yysindex[*yystack.s_mark]) && (yyn += YYERRCODE) >= 0 &&
                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: state %d, error recovery shifting\
 to state %d\n", YYPREFIX, *yystack.s_mark, yytable[yyn]);
#endif
                if (yystack.s_mark >= yystack.s_last && yygrowstack(&yystack) == YYENOMEM)
                {
                    goto yyoverflow;
                }
                yystate = yytable[yyn];
                *++yystack.s_mark = yytable[yyn];
                *++yystack.l_mark = yylval;
                goto yyloop;
            }
            else
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: error recovery discarding state %d\n",
                            YYPREFIX, *yystack.s_mark);
#endif
                if (yystack.s_mark <= yystack.s_base) goto yyabort;
                --yystack.s_mark;
                --yystack.l_mark;
            }
        }
    }
    else
    {
        if (yychar == YYEOF) goto yyabort;
#if YYDEBUG
        if (yydebug)
        {
            yys = yyname[YYTRANSLATE(yychar)];
            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
        yychar = YYEMPTY;
        goto yyloop;
    }

yyreduce:
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
                YYPREFIX, yystate, yyn, yyrule[yyn]);
#endif
    yym = yylen[yyn];
    if (yym)
        yyval = yystack.l_mark[1-yym];
    else
        memset(&yyval, 0, sizeof yyval);
    switch (yyn)
    {
case 3:
#line 238 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode(OP_TYPE);
			  write_exp_elt_type(yystack.l_mark[0].tval);
			  write_exp_elt_opcode(OP_TYPE);}
break;
case 5:
#line 246 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (BINOP_COMMA); }
break;
case 6:
#line 251 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (UNOP_IND); }
break;
case 7:
#line 255 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (UNOP_ADDR); }
break;
case 8:
#line 259 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (UNOP_NEG); }
break;
case 9:
#line 263 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (UNOP_LOGICAL_NOT); }
break;
case 10:
#line 267 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (UNOP_COMPLEMENT); }
break;
case 11:
#line 271 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (UNOP_PREINCREMENT); }
break;
case 12:
#line 275 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (UNOP_PREDECREMENT); }
break;
case 13:
#line 279 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (UNOP_POSTINCREMENT); }
break;
case 14:
#line 283 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (UNOP_POSTDECREMENT); }
break;
case 15:
#line 287 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (UNOP_SIZEOF); }
break;
case 16:
#line 291 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (STRUCTOP_PTR);
			  write_exp_string (yystack.l_mark[0].sval);
			  write_exp_elt_opcode (STRUCTOP_PTR); }
break;
case 17:
#line 297 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ /* exp->type::name becomes exp->*(&type::name) */
			  /* Note: this doesn't work if name is a
			     static member!  FIXME */
			  write_exp_elt_opcode (UNOP_ADDR);
			  write_exp_elt_opcode (STRUCTOP_MPTR); }
break;
case 18:
#line 305 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (STRUCTOP_MPTR); }
break;
case 19:
#line 309 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (STRUCTOP_STRUCT);
			  write_exp_string (yystack.l_mark[0].sval);
			  write_exp_elt_opcode (STRUCTOP_STRUCT); }
break;
case 20:
#line 315 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ /* exp.type::name becomes exp.*(&type::name) */
			  /* Note: this doesn't work if name is a
			     static member!  FIXME */
			  write_exp_elt_opcode (UNOP_ADDR);
			  write_exp_elt_opcode (STRUCTOP_MEMBER); }
break;
case 21:
#line 323 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (STRUCTOP_MEMBER); }
break;
case 22:
#line 327 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (BINOP_SUBSCRIPT); }
break;
case 23:
#line 333 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ start_arglist (); }
break;
case 24:
#line 335 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (OP_FUNCALL);
			  write_exp_elt_longcst ((LONGEST) end_arglist ());
			  write_exp_elt_opcode (OP_FUNCALL); }
break;
case 25:
#line 341 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ start_arglist (); }
break;
case 27:
#line 348 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ arglist_len = 1; }
break;
case 28:
#line 352 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ arglist_len++; }
break;
case 29:
#line 356 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.lval = end_arglist () - 1; }
break;
case 30:
#line 359 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (OP_ARRAY);
			  write_exp_elt_longcst ((LONGEST) 0);
			  write_exp_elt_longcst ((LONGEST) yystack.l_mark[0].lval);
			  write_exp_elt_opcode (OP_ARRAY); }
break;
case 31:
#line 366 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (UNOP_MEMVAL);
			  write_exp_elt_type (yystack.l_mark[-2].tval);
			  write_exp_elt_opcode (UNOP_MEMVAL); }
break;
case 32:
#line 372 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (UNOP_CAST);
			  write_exp_elt_type (yystack.l_mark[-2].tval);
			  write_exp_elt_opcode (UNOP_CAST); }
break;
case 33:
#line 378 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ }
break;
case 34:
#line 384 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (BINOP_REPEAT); }
break;
case 35:
#line 388 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (BINOP_MUL); }
break;
case 36:
#line 392 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (BINOP_DIV); }
break;
case 37:
#line 396 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (BINOP_REM); }
break;
case 38:
#line 400 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (BINOP_ADD); }
break;
case 39:
#line 404 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (BINOP_SUB); }
break;
case 40:
#line 408 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (BINOP_LSH); }
break;
case 41:
#line 412 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (BINOP_RSH); }
break;
case 42:
#line 416 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (BINOP_EQUAL); }
break;
case 43:
#line 420 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (BINOP_NOTEQUAL); }
break;
case 44:
#line 424 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (BINOP_LEQ); }
break;
case 45:
#line 428 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (BINOP_GEQ); }
break;
case 46:
#line 432 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (BINOP_LESS); }
break;
case 47:
#line 436 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (BINOP_GTR); }
break;
case 48:
#line 440 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (BINOP_BITWISE_AND); }
break;
case 49:
#line 444 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (BINOP_BITWISE_XOR); }
break;
case 50:
#line 448 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (BINOP_BITWISE_IOR); }
break;
case 51:
#line 452 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (BINOP_LOGICAL_AND); }
break;
case 52:
#line 456 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (BINOP_LOGICAL_OR); }
break;
case 53:
#line 460 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (TERNOP_COND); }
break;
case 54:
#line 464 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (BINOP_ASSIGN); }
break;
case 55:
#line 468 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (BINOP_ASSIGN_MODIFY);
			  write_exp_elt_opcode (yystack.l_mark[-1].opcode);
			  write_exp_elt_opcode (BINOP_ASSIGN_MODIFY); }
break;
case 56:
#line 474 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (OP_LONG);
			  write_exp_elt_type (yystack.l_mark[0].typed_val_int.type);
			  write_exp_elt_longcst ((LONGEST)(yystack.l_mark[0].typed_val_int.val));
			  write_exp_elt_opcode (OP_LONG); }
break;
case 57:
#line 481 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ YYSTYPE val;
			  parse_number (yystack.l_mark[0].ssym.stoken.ptr, yystack.l_mark[0].ssym.stoken.length, 0, &val);
			  write_exp_elt_opcode (OP_LONG);
			  write_exp_elt_type (val.typed_val_int.type);
			  write_exp_elt_longcst ((LONGEST)val.typed_val_int.val);
			  write_exp_elt_opcode (OP_LONG);
			}
break;
case 58:
#line 492 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (OP_DOUBLE);
			  write_exp_elt_type (yystack.l_mark[0].typed_val_float.type);
			  write_exp_elt_dblcst (yystack.l_mark[0].typed_val_float.dval);
			  write_exp_elt_opcode (OP_DOUBLE); }
break;
case 61:
#line 506 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (OP_LONG);
			  write_exp_elt_type (builtin_type_int);
			  CHECK_TYPEDEF (yystack.l_mark[-1].tval);
			  write_exp_elt_longcst ((LONGEST) TYPE_LENGTH (yystack.l_mark[-1].tval));
			  write_exp_elt_opcode (OP_LONG); }
break;
case 62:
#line 514 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ /* C strings are converted into array constants with
			     an explicit null byte added at the end.  Thus
			     the array upper bound is the string length.
			     There is no such thing in C as a completely empty
			     string. */
			  char *sp = yystack.l_mark[0].sval.ptr; int count = yystack.l_mark[0].sval.length;
			  while (count-- > 0)
			    {
			      write_exp_elt_opcode (OP_LONG);
			      write_exp_elt_type (builtin_type_char);
			      write_exp_elt_longcst ((LONGEST)(*sp++));
			      write_exp_elt_opcode (OP_LONG);
			    }
			  write_exp_elt_opcode (OP_LONG);
			  write_exp_elt_type (builtin_type_char);
			  write_exp_elt_longcst ((LONGEST)'\0');
			  write_exp_elt_opcode (OP_LONG);
			  write_exp_elt_opcode (OP_ARRAY);
			  write_exp_elt_longcst ((LONGEST) 0);
			  write_exp_elt_longcst ((LONGEST) (yystack.l_mark[0].sval.length));
			  write_exp_elt_opcode (OP_ARRAY); }
break;
case 63:
#line 539 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (OP_LONG);
                          write_exp_elt_type (builtin_type_bool);
                          write_exp_elt_longcst ((LONGEST) 1);
                          write_exp_elt_opcode (OP_LONG); }
break;
case 64:
#line 546 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ write_exp_elt_opcode (OP_LONG);
                          write_exp_elt_type (builtin_type_bool);
                          write_exp_elt_longcst ((LONGEST) 0);
                          write_exp_elt_opcode (OP_LONG); }
break;
case 65:
#line 555 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{
			  if (yystack.l_mark[0].ssym.sym)
			    yyval.bval = SYMBOL_BLOCK_VALUE (yystack.l_mark[0].ssym.sym);
			  else
			    error ("No file or function \"%s\".",
				   copy_name (yystack.l_mark[0].ssym.stoken));
			}
break;
case 66:
#line 563 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{
			  yyval.bval = yystack.l_mark[0].bval;
			}
break;
case 67:
#line 569 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ struct symbol *tem
			    = lookup_symbol (copy_name (yystack.l_mark[0].sval), yystack.l_mark[-2].bval,
					     VAR_DOMAIN, (int *) NULL,
					     (struct symtab **) NULL);
			  if (!tem || SYMBOL_CLASS (tem) != LOC_BLOCK)
			    error ("No function \"%s\" in specified context.",
				   copy_name (yystack.l_mark[0].sval));
			  yyval.bval = SYMBOL_BLOCK_VALUE (tem); }
break;
case 68:
#line 580 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ struct symbol *sym;
			  sym = lookup_symbol (copy_name (yystack.l_mark[0].sval), yystack.l_mark[-2].bval,
					       VAR_DOMAIN, (int *) NULL,
					       (struct symtab **) NULL);
			  if (sym == 0)
			    error ("No symbol \"%s\" in specified context.",
				   copy_name (yystack.l_mark[0].sval));

			  write_exp_elt_opcode (OP_VAR_VALUE);
			  /* block_found is set by lookup_symbol.  */
			  write_exp_elt_block (block_found);
			  write_exp_elt_sym (sym);
			  write_exp_elt_opcode (OP_VAR_VALUE); }
break;
case 69:
#line 596 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{
			  struct type *type = yystack.l_mark[-2].tval;
			  if (TYPE_CODE (type) != TYPE_CODE_STRUCT
			      && TYPE_CODE (type) != TYPE_CODE_UNION
			      && TYPE_CODE (type) != TYPE_CODE_NAMESPACE)
			    error ("`%s' is not defined as an aggregate type.",
				   TYPE_NAME (type));

			  write_exp_elt_opcode (OP_SCOPE);
			  write_exp_elt_type (type);
			  write_exp_string (yystack.l_mark[0].sval);
			  write_exp_elt_opcode (OP_SCOPE);
			}
break;
case 70:
#line 610 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{
			  struct type *type = yystack.l_mark[-3].tval;
			  struct stoken tmp_token;
			  if (TYPE_CODE (type) != TYPE_CODE_STRUCT
			      && TYPE_CODE (type) != TYPE_CODE_UNION
			      && TYPE_CODE (type) != TYPE_CODE_NAMESPACE)
			    error ("`%s' is not defined as an aggregate type.",
				   TYPE_NAME (type));

			  tmp_token.ptr = (char*) alloca (yystack.l_mark[0].sval.length + 2);
			  tmp_token.length = yystack.l_mark[0].sval.length + 1;
			  tmp_token.ptr[0] = '~';
			  memcpy (tmp_token.ptr+1, yystack.l_mark[0].sval.ptr, yystack.l_mark[0].sval.length);
			  tmp_token.ptr[tmp_token.length] = 0;

			  /* Check for valid destructor name.  */
			  destructor_name_p (tmp_token.ptr, type);
			  write_exp_elt_opcode (OP_SCOPE);
			  write_exp_elt_type (type);
			  write_exp_string (tmp_token);
			  write_exp_elt_opcode (OP_SCOPE);
			}
break;
case 72:
#line 636 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{
			  char *name = copy_name (yystack.l_mark[0].sval);
			  struct symbol *sym;
			  struct minimal_symbol *msymbol;

			  sym =
			    lookup_symbol (name, (const struct block *) NULL,
					   VAR_DOMAIN, (int *) NULL,
					   (struct symtab **) NULL);
			  if (sym)
			    {
			      write_exp_elt_opcode (OP_VAR_VALUE);
			      write_exp_elt_block (NULL);
			      write_exp_elt_sym (sym);
			      write_exp_elt_opcode (OP_VAR_VALUE);
			      break;
			    }

			  msymbol = lookup_minimal_symbol (name, NULL, NULL);
			  if (msymbol != NULL)
			    {
			      write_exp_msymbol (msymbol,
						 lookup_function_type (builtin_type_int),
						 builtin_type_int);
			    }
			  else
			    if (!have_full_symbols () && !have_partial_symbols ())
			      error ("No symbol table is loaded.  Use the \"file\" command.");
			    else
			      error ("No symbol \"%s\" in current context.", name);
			}
break;
case 73:
#line 670 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ struct symbol *sym = yystack.l_mark[0].ssym.sym;

			  if (sym)
			    {
			      if (symbol_read_needs_frame (sym))
				{
				  if (innermost_block == 0 ||
				      contained_in (block_found, 
						    innermost_block))
				    innermost_block = block_found;
				}

			      write_exp_elt_opcode (OP_VAR_VALUE);
			      /* We want to use the selected frame, not
				 another more inner frame which happens to
				 be in the same block.  */
			      write_exp_elt_block (NULL);
			      write_exp_elt_sym (sym);
			      write_exp_elt_opcode (OP_VAR_VALUE);
			    }
			  else if (yystack.l_mark[0].ssym.is_a_field_of_this)
			    {
			      /* C++: it hangs off of `this'.  Must
			         not inadvertently convert from a method call
				 to data ref.  */
			      if (innermost_block == 0 || 
				  contained_in (block_found, innermost_block))
				innermost_block = block_found;
			      write_exp_elt_opcode (OP_THIS);
			      write_exp_elt_opcode (OP_THIS);
			      write_exp_elt_opcode (STRUCTOP_PTR);
			      write_exp_string (yystack.l_mark[0].ssym.stoken);
			      write_exp_elt_opcode (STRUCTOP_PTR);
			    }
			  else
			    {
			      struct minimal_symbol *msymbol;
			      char *arg = copy_name (yystack.l_mark[0].ssym.stoken);

			      msymbol =
				lookup_minimal_symbol (arg, NULL, NULL);
			      if (msymbol != NULL)
				{
				  write_exp_msymbol (msymbol,
						     lookup_function_type (builtin_type_int),
						     builtin_type_int);
				}
			      else if (!have_full_symbols () && !have_partial_symbols ())
				error ("No symbol table is loaded.  Use the \"file\" command.");
			      else
				error ("No symbol \"%s\" in current context.",
				       copy_name (yystack.l_mark[0].ssym.stoken));
			    }
			}
break;
case 74:
#line 727 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ push_type_address_space (copy_name (yystack.l_mark[0].ssym.stoken));
		  push_type (tp_space_identifier);
		}
break;
case 82:
#line 749 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ push_type (tp_pointer); yyval.voidval = 0; }
break;
case 83:
#line 751 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ push_type (tp_pointer); yyval.voidval = yystack.l_mark[0].voidval; }
break;
case 84:
#line 753 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ push_type (tp_reference); yyval.voidval = 0; }
break;
case 85:
#line 755 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ push_type (tp_reference); yyval.voidval = yystack.l_mark[0].voidval; }
break;
case 87:
#line 760 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.voidval = yystack.l_mark[-1].voidval; }
break;
case 88:
#line 762 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{
			  push_type_int (yystack.l_mark[0].lval);
			  push_type (tp_array);
			}
break;
case 89:
#line 767 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{
			  push_type_int (yystack.l_mark[0].lval);
			  push_type (tp_array);
			  yyval.voidval = 0;
			}
break;
case 90:
#line 774 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ push_type (tp_function); }
break;
case 91:
#line 776 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ push_type (tp_function); }
break;
case 92:
#line 780 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.lval = -1; }
break;
case 93:
#line 782 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.lval = yystack.l_mark[-1].typed_val_int.val; }
break;
case 94:
#line 786 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.voidval = 0; }
break;
case 95:
#line 788 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ free (yystack.l_mark[-1].tvec); yyval.voidval = 0; }
break;
case 97:
#line 801 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tval = lookup_member_type (builtin_type_int, yystack.l_mark[-2].tval); }
break;
case 98:
#line 806 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tval = yystack.l_mark[0].tsym.type; }
break;
case 99:
#line 808 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tval = builtin_type_int; }
break;
case 100:
#line 810 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tval = builtin_type_long; }
break;
case 101:
#line 812 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tval = builtin_type_short; }
break;
case 102:
#line 814 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tval = builtin_type_long; }
break;
case 103:
#line 816 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tval = builtin_type_long; }
break;
case 104:
#line 818 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tval = builtin_type_long; }
break;
case 105:
#line 820 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tval = builtin_type_long; }
break;
case 106:
#line 822 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tval = builtin_type_unsigned_long; }
break;
case 107:
#line 824 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tval = builtin_type_unsigned_long; }
break;
case 108:
#line 826 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tval = builtin_type_unsigned_long; }
break;
case 109:
#line 828 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tval = builtin_type_long_long; }
break;
case 110:
#line 830 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tval = builtin_type_long_long; }
break;
case 111:
#line 832 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tval = builtin_type_long_long; }
break;
case 112:
#line 834 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tval = builtin_type_long_long; }
break;
case 113:
#line 836 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tval = builtin_type_long_long; }
break;
case 114:
#line 838 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tval = builtin_type_long_long; }
break;
case 115:
#line 840 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tval = builtin_type_unsigned_long_long; }
break;
case 116:
#line 842 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tval = builtin_type_unsigned_long_long; }
break;
case 117:
#line 844 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tval = builtin_type_unsigned_long_long; }
break;
case 118:
#line 846 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tval = builtin_type_unsigned_long_long; }
break;
case 119:
#line 848 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tval = builtin_type_short; }
break;
case 120:
#line 850 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tval = builtin_type_short; }
break;
case 121:
#line 852 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tval = builtin_type_short; }
break;
case 122:
#line 854 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tval = builtin_type_unsigned_short; }
break;
case 123:
#line 856 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tval = builtin_type_unsigned_short; }
break;
case 124:
#line 858 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tval = builtin_type_unsigned_short; }
break;
case 125:
#line 860 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tval = builtin_type_double; }
break;
case 126:
#line 862 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tval = builtin_type_long_double; }
break;
case 127:
#line 864 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tval = lookup_struct (copy_name (yystack.l_mark[0].sval),
					      expression_context_block); }
break;
case 128:
#line 867 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tval = lookup_struct (copy_name (yystack.l_mark[0].sval),
					      expression_context_block); }
break;
case 129:
#line 870 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tval = lookup_union (copy_name (yystack.l_mark[0].sval),
					     expression_context_block); }
break;
case 130:
#line 873 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tval = lookup_enum (copy_name (yystack.l_mark[0].sval),
					    expression_context_block); }
break;
case 131:
#line 876 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tval = lookup_unsigned_typename (TYPE_NAME(yystack.l_mark[0].tsym.type)); }
break;
case 132:
#line 878 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tval = builtin_type_unsigned_int; }
break;
case 133:
#line 880 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tval = lookup_signed_typename (TYPE_NAME(yystack.l_mark[0].tsym.type)); }
break;
case 134:
#line 882 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tval = builtin_type_int; }
break;
case 135:
#line 887 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tval = lookup_template_type(copy_name(yystack.l_mark[-3].sval), yystack.l_mark[-1].tval,
						    expression_context_block);
			}
break;
case 136:
#line 891 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tval = follow_types (yystack.l_mark[0].tval); }
break;
case 137:
#line 893 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tval = follow_types (yystack.l_mark[-1].tval); }
break;
case 139:
#line 943 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{
		  struct type *type = yystack.l_mark[-2].tval;
		  struct type *new_type;
		  char *ncopy = alloca (yystack.l_mark[0].sval.length + 1);

		  memcpy (ncopy, yystack.l_mark[0].sval.ptr, yystack.l_mark[0].sval.length);
		  ncopy[yystack.l_mark[0].sval.length] = '\0';

		  if (TYPE_CODE (type) != TYPE_CODE_STRUCT
		      && TYPE_CODE (type) != TYPE_CODE_UNION
		      && TYPE_CODE (type) != TYPE_CODE_NAMESPACE)
		    error ("`%s' is not defined as an aggregate type.",
			   TYPE_NAME (type));

		  new_type = cp_lookup_nested_type (type, ncopy,
						    expression_context_block);
		  if (new_type == NULL)
		    error ("No type \"%s\" within class or namespace \"%s\".",
			   ncopy, TYPE_NAME (type));
		  
		  yyval.tval = new_type;
		}
break;
case 141:
#line 969 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{
		  yyval.tsym.stoken.ptr = "int";
		  yyval.tsym.stoken.length = 3;
		  yyval.tsym.type = builtin_type_int;
		}
break;
case 142:
#line 975 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{
		  yyval.tsym.stoken.ptr = "long";
		  yyval.tsym.stoken.length = 4;
		  yyval.tsym.type = builtin_type_long;
		}
break;
case 143:
#line 981 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{
		  yyval.tsym.stoken.ptr = "short";
		  yyval.tsym.stoken.length = 5;
		  yyval.tsym.type = builtin_type_short;
		}
break;
case 144:
#line 990 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tvec = (struct type **) malloc (sizeof (struct type *) * 2);
		  yyval.ivec[0] = 1;	/* Number of types in vector */
		  yyval.tvec[1] = yystack.l_mark[0].tval;
		}
break;
case 145:
#line 995 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ int len = sizeof (struct type *) * (++(yystack.l_mark[-2].ivec[0]) + 1);
		  yyval.tvec = (struct type **) realloc ((char *) yystack.l_mark[-2].tvec, len);
		  yyval.tvec[yyval.ivec[0]] = yystack.l_mark[0].tval;
		}
break;
case 147:
#line 1003 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.tval = follow_types (yystack.l_mark[-3].tval); }
break;
case 150:
#line 1011 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ push_type (tp_const);
			  push_type (tp_volatile); 
			}
break;
case 151:
#line 1015 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ push_type (tp_const); }
break;
case 152:
#line 1017 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ push_type (tp_volatile); }
break;
case 153:
#line 1020 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.sval = yystack.l_mark[0].ssym.stoken; }
break;
case 154:
#line 1021 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.sval = yystack.l_mark[0].ssym.stoken; }
break;
case 155:
#line 1022 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.sval = yystack.l_mark[0].tsym.stoken; }
break;
case 156:
#line 1023 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/c-exp.y"
	{ yyval.sval = yystack.l_mark[0].ssym.stoken; }
break;
#line 2997 "c-exp.c"
    }
    yystack.s_mark -= yym;
    yystate = *yystack.s_mark;
    yystack.l_mark -= yym;
    yym = yylhs[yyn];
    if (yystate == 0 && yym == 0)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: after reduction, shifting from state 0 to\
 state %d\n", YYPREFIX, YYFINAL);
#endif
        yystate = YYFINAL;
        *++yystack.s_mark = YYFINAL;
        *++yystack.l_mark = yyval;
        if (yychar < 0)
        {
            if ((yychar = YYLEX) < 0) yychar = YYEOF;
#if YYDEBUG
            if (yydebug)
            {
                yys = yyname[YYTRANSLATE(yychar)];
                printf("%sdebug: state %d, reading %d (%s)\n",
                        YYPREFIX, YYFINAL, yychar, yys);
            }
#endif
        }
        if (yychar == YYEOF) goto yyaccept;
        goto yyloop;
    }
    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
        yystate = yytable[yyn];
    else
        yystate = yydgoto[yym];
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: after reduction, shifting from state %d \
to state %d\n", YYPREFIX, *yystack.s_mark, yystate);
#endif
    if (yystack.s_mark >= yystack.s_last && yygrowstack(&yystack) == YYENOMEM)
    {
        goto yyoverflow;
    }
    *++yystack.s_mark = (YYINT) yystate;
    *++yystack.l_mark = yyval;
    goto yyloop;

yyoverflow:
    YYERROR_CALL("yacc stack overflow");

yyabort:
    yyfreestack(&yystack);
    return (1);

yyaccept:
    yyfreestack(&yystack);
    return (0);
}
