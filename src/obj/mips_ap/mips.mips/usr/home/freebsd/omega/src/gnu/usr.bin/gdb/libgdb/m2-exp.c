/* original parser id follows */
/* yysccsid[] = "@(#)yaccpar	1.9 (Berkeley) 02/21/93" */
/* (use YYMAJOR/YYMINOR for ifdefs dependent on parser version) */

#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 9
#define YYPATCH 20141006

#define YYEMPTY        (-1)
#define yyclearin      (yychar = YYEMPTY)
#define yyerrok        (yyerrflag = 0)
#define YYRECOVERING() (yyerrflag != 0)
#define YYENOMEM       (-2)
#define YYEOF          0
#define YYPREFIX "yy"

#define YYPURE 0

#line 42 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"

#include "defs.h"
#include "gdb_string.h"
#include "expression.h"
#include "language.h"
#include "value.h"
#include "parser-defs.h"
#include "m2-lang.h"
#include "bfd.h" /* Required by objfiles.h.  */
#include "symfile.h" /* Required by objfiles.h.  */
#include "objfiles.h" /* For have_full_symbols and have_partial_symbols */
#include "block.h"

/* Remap normal yacc parser interface names (yyparse, yylex, yyerror, etc),
   as well as gratuitiously global symbol names, so we can have multiple
   yacc generated parsers in gdb.  Note that these are only the variables
   produced by yacc.  If other parser generators (bison, byacc, etc) produce
   additional global names that conflict at link time, then those parser
   generators need to be fixed instead of adding those names to this list. */

#define	yymaxdepth m2_maxdepth
#define	yyparse	m2_parse
#define	yylex	m2_lex
#define	yyerror	m2_error
#define	yylval	m2_lval
#define	yychar	m2_char
#define	yydebug	m2_debug
#define	yypact	m2_pact
#define	yyr1	m2_r1
#define	yyr2	m2_r2
#define	yydef	m2_def
#define	yychk	m2_chk
#define	yypgo	m2_pgo
#define	yyact	m2_act
#define	yyexca	m2_exca
#define	yyerrflag m2_errflag
#define	yynerrs	m2_nerrs
#define	yyps	m2_ps
#define	yypv	m2_pv
#define	yys	m2_s
#define	yy_yys	m2_yys
#define	yystate	m2_state
#define	yytmp	m2_tmp
#define	yyv	m2_v
#define	yy_yyv	m2_yyv
#define	yyval	m2_val
#define	yylloc	m2_lloc
#define	yyreds	m2_reds		/* With YYDEBUG defined */
#define	yytoks	m2_toks		/* With YYDEBUG defined */
#define yyname	m2_name		/* With YYDEBUG defined */
#define yyrule	m2_rule		/* With YYDEBUG defined */
#define yylhs	m2_yylhs
#define yylen	m2_yylen
#define yydefred m2_yydefred
#define yydgoto	m2_yydgoto
#define yysindex m2_yysindex
#define yyrindex m2_yyrindex
#define yygindex m2_yygindex
#define yytable	 m2_yytable
#define yycheck	 m2_yycheck

#ifndef YYDEBUG
#define	YYDEBUG 1		/* Default to yydebug support */
#endif

#define YYFPRINTF parser_fprintf

int yyparse (void);

static int yylex (void);

void yyerror (char *);

#if 0
static char *make_qualname (char *, char *);
#endif

static int parse_number (int);

/* The sign of the number being parsed. */
static int number_sign = 1;

/* The block that the module specified by the qualifer on an identifer is
   contained in, */
#if 0
static struct block *modblock=0;
#endif

#line 136 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
#ifdef YYSTYPE
#undef  YYSTYPE_IS_DECLARED
#define YYSTYPE_IS_DECLARED 1
#endif
#ifndef YYSTYPE_IS_DECLARED
#define YYSTYPE_IS_DECLARED 1
typedef union
  {
    LONGEST lval;
    ULONGEST ulval;
    DOUBLEST dval;
    struct symbol *sym;
    struct type *tval;
    struct stoken sval;
    int voidval;
    struct block *bval;
    enum exp_opcode opcode;
    struct internalvar *ivar;

    struct type **tvec;
    int *ivec;
  } YYSTYPE;
#endif /* !YYSTYPE_IS_DECLARED */
#line 134 "m2-exp.c"

/* compatibility with bison */
#ifdef YYPARSE_PARAM
/* compatibility with FreeBSD */
# ifdef YYPARSE_PARAM_TYPE
#  define YYPARSE_DECL() yyparse(YYPARSE_PARAM_TYPE YYPARSE_PARAM)
# else
#  define YYPARSE_DECL() yyparse(void *YYPARSE_PARAM)
# endif
#else
# define YYPARSE_DECL() yyparse(void)
#endif

/* Parameters sent to lex. */
#ifdef YYLEX_PARAM
# define YYLEX_DECL() yylex(void *YYLEX_PARAM)
# define YYLEX yylex(YYLEX_PARAM)
#else
# define YYLEX_DECL() yylex(void)
# define YYLEX yylex()
#endif

/* Parameters sent to yyerror. */
#ifndef YYERROR_DECL
#define YYERROR_DECL() yyerror(const char *s)
#endif
#ifndef YYERROR_CALL
#define YYERROR_CALL(msg) yyerror(msg)
#endif

extern int YYPARSE_DECL();

#define INT 257
#define HEX 258
#define ERROR 259
#define UINT 260
#define M2_TRUE 261
#define M2_FALSE 262
#define CHAR 263
#define FLOAT 264
#define STRING 265
#define NAME 266
#define BLOCKNAME 267
#define IDENT 268
#define VARNAME 269
#define TYPENAME 270
#define SIZE 271
#define CAP 272
#define ORD 273
#define HIGH 274
#define ABS 275
#define MIN_FUNC 276
#define MAX_FUNC 277
#define FLOAT_FUNC 278
#define VAL 279
#define CHR 280
#define ODD 281
#define TRUNC 282
#define INC 283
#define DEC 284
#define INCL 285
#define EXCL 286
#define COLONCOLON 287
#define INTERNAL_VAR 288
#define ABOVE_COMMA 289
#define ASSIGN 290
#define LEQ 291
#define GEQ 292
#define NOTEQUAL 293
#define IN 294
#define OROR 295
#define LOGICAL_AND 296
#define DIV 297
#define MOD 298
#define UNARY 299
#define DOT 300
#define NOT 301
#define QID 302
#define YYERRCODE 256
typedef int YYINT;
static const YYINT yylhs[] = {                           -1,
    0,    0,    2,    1,    8,    1,    1,    1,    9,    9,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    3,    3,   12,    1,   13,    1,   10,   10,   10,
   11,   11,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    6,    7,    7,    4,    4,    4,    4,    5,
};
static const YYINT yylen[] = {                            2,
    1,    1,    1,    2,    0,    3,    2,    2,    1,    1,
    4,    4,    4,    4,    4,    4,    4,    6,    4,    4,
    4,    2,    4,    6,    4,    6,    3,    1,    3,    6,
    6,    3,    4,    0,    5,    0,    5,    0,    1,    3,
    1,    3,    4,    4,    3,    3,    3,    3,    3,    3,
    3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
    3,    3,    1,    1,    1,    1,    1,    1,    1,    4,
    1,    1,    1,    3,    1,    1,    3,    1,    1,
};
static const YYINT yydefred[] = {                         0,
   65,   66,   63,   64,   67,   68,   71,   78,   73,   79,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   76,    0,    5,    0,
    9,   10,    0,    0,    0,    2,   28,   69,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    4,    0,   34,   36,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   45,
    0,    0,   32,    0,    0,    0,    0,    0,    0,    0,
    0,    0,   29,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,   27,    0,    0,    0,    0,   77,   74,
   70,   11,   12,   14,   13,   15,   16,   17,    0,   19,
   20,   21,    0,   23,    0,   25,    0,    0,    0,    0,
    0,    0,    0,   44,   33,    0,    0,    0,    0,    0,
    0,   35,   37,   18,   24,   26,   30,   31,    0,
};
static const YYINT yydgoto[] = {                         34,
   64,   36,   37,   38,   45,   40,   41,   62,   42,   66,
  162,  135,  136,
};
static const YYINT yysindex[] = {                      1587,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
 1711,  -40,  -21,   -8,   -6,   -3,   -2,   24,   31,   37,
   38,   39,   57,   58,   59,   77,    0, 1587,    0, 1587,
    0,    0, 1587,    0, 1658,    0,    0,    0,  -15, -281,
    0, 1587, 1587,  -24,  -15, 1587, 1587, 1587, 1587, -239,
 -239, 1587, -239, 1587, 1587, 1587, 1587, 1587, 1587, 1587,
  -24, 1587,  886, 1658,  -37,  -36, 1587, 1587, 1587, 1587,
 1587, 1587, 1587, 1587, -118, 1587, 1587, 1587, 1587, 1587,
 1587, 1587, 1587, 1587,    0, -214,    0,    0, 1587, 1587,
 -238,  -24,  -27,  897,  952,  963, 1018,   78,   79, 1046,
   36, 1107, 1171, 1229,  739,  831, 1240, 1315,  -24,    0,
 1587, 1587,    0, 1669,  860,  860,  860,  860,  860,  860,
  860, 1587,    0,   -5,  -25,  507,  117,  366,  366,  -24,
  -24,  -24,  -24,    0, 1587, 1587, 1326,  -11,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0, 1587,    0,
    0,    0, 1587,    0, 1587,    0, 1587, 1587,  -24, 1658,
 1658,  -42,  -20,    0,    0, 1381, 1392, 1450, 1507, 1600,
 1587,    0,    0,    0,    0,    0,    0,    0, 1658,
};
static const YYINT yyrindex[] = {                         0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,   -9,    0,  121,    0,    0,    0,  122,    0,
    1,    0,    0,   12,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   40,    0,    0,  -34,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   -9,
    0,   68,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  106,    0,
    0,    0,    0,   49,  529,  551,  559,  596,  618,  626,
  673,   -9,    0,    0,  522,  500,  285,  191,  463,  134,
  145,  219,  409,    0,    0,  -14,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  433,  -18,
  -35,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  -33,
};
static const YYINT yygindex[] = {                         0,
 1998,    0,   48,    0,  171,    0,    0,    0,    0,  -86,
    0,    0,    0,
};
#define YYTABLESIZE 2169
static const YYINT yytable[] = {                         46,
   75,  171,   89,  138,  122,   91,   39,  112,   41,   39,
   42,   22,   89,  141,   88,   88,   81,   79,   47,   80,
  173,   82,   40,  112,   89,   40,   38,  139,  140,   38,
   10,   48,  112,   49,   38,   75,   50,   51,   78,    7,
   75,   75,   75,   75,   75,   75,   22,   75,   62,  163,
  172,  134,   22,   22,   22,   22,   22,   41,   22,   42,
   75,   75,   75,   52,   75,   87,   87,    8,   85,   85,
   53,   22,   22,   22,    7,   22,   54,   55,   56,  149,
    7,    7,    7,    7,    7,   90,    7,  111,  113,   62,
   39,   75,   62,   75,   75,   90,   57,   58,   59,    7,
    7,    7,    8,    7,   22,    6,   40,   90,    8,    8,
    8,    8,    8,  165,    8,   38,   60,   90,  146,  147,
    1,    3,  123,    0,    0,   75,    0,    8,    8,    8,
    0,    8,    7,   47,    0,    0,   22,    0,    0,    0,
    6,   62,    0,    0,   48,    0,    6,    6,    6,    6,
    6,   10,    6,    0,    0,    0,   88,    0,   81,   79,
    8,   80,    0,   82,    7,    6,    6,    6,   47,    6,
   39,    0,    0,   62,   47,   47,   47,   47,   47,   48,
   47,    0,    0,    0,    0,   48,   48,   48,   48,   48,
   51,   48,    8,   47,   47,   47,    0,   47,    6,    0,
    0,    0,    0,   65,   48,   48,   48,   87,   48,    0,
   85,    0,    0,   93,    0,    0,    0,    0,   49,    0,
   98,   99,    0,  101,    0,   51,   47,    0,    0,    0,
    6,   51,    0,   51,   51,   51,    0,   48,    0,    0,
    0,    0,    0,    0,    0,  124,    0,    0,    0,    0,
   51,   51,   51,   49,   51,    0,    0,    0,   47,   49,
   49,   49,   49,   49,    0,   49,    0,    0,    0,   48,
   77,   83,   84,    0,   86,   86,    0,    0,   49,   49,
   49,    0,   49,   51,   46,    0,    0,   72,    0,    0,
   75,   75,   75,   75,   75,   75,   75,   75,   75,    0,
   75,   22,   22,   22,   22,   22,   22,   22,   22,   22,
    0,   49,    0,    0,    0,   51,    0,    0,    0,   46,
    0,    0,    0,    0,    0,   46,    0,    0,   46,    7,
    7,    7,    7,    7,    7,    7,    7,    7,    0,    0,
    0,    0,    0,   49,   46,   46,   46,    0,   46,    0,
    0,    0,    0,    0,    0,    0,    0,    8,    8,    8,
    8,    8,    8,    8,    8,    8,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,   46,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    6,    6,    6,    6,    6,
    6,    6,    6,    6,    0,   88,    0,   81,   50,   46,
    0,    0,   82,   83,   84,    0,   86,    0,    0,    0,
    0,    0,    0,   47,   47,   47,   47,   47,   47,   47,
   47,   47,   43,    0,   48,   48,   48,   48,   48,   48,
   48,   48,   48,   50,    0,    0,    0,    0,    0,   50,
   50,   50,   50,   50,    0,   50,   87,    0,    0,   85,
    0,    0,   52,    0,    0,    0,    0,   43,   50,   50,
   50,    0,   50,   43,   43,   43,   43,   43,    0,   43,
   51,   51,   51,   51,   51,   51,   51,    0,    0,    0,
    0,    0,   43,   43,   43,    0,   43,   52,    0,   60,
    0,   50,    0,   52,    0,   52,   52,   52,   49,   49,
   49,   49,   49,   49,   49,   49,   49,    0,    0,    0,
    0,   61,   52,   52,   52,   43,   52,    0,   58,    0,
    0,    0,    0,   50,   60,    0,    0,    0,    0,    0,
   60,    0,    0,   60,    0,    0,   88,    0,   81,   79,
   59,   80,    0,   82,    0,   52,   61,   43,   56,   60,
   60,   60,   61,   58,    0,   61,    0,    0,    0,   58,
   78,    0,   58,    0,   46,   46,   46,   46,   46,   46,
   46,   61,   61,   61,    0,   59,    0,   52,   58,   58,
   58,   59,   60,   56,   59,   57,    0,   87,    0,   56,
   85,    0,   56,    0,    0,    0,    0,    0,    0,    0,
   59,   59,   59,    0,   61,    0,    0,   53,   56,   56,
   56,   58,    0,    0,   60,   54,    0,    0,    0,    0,
   57,    0,    0,    0,    0,    0,   57,    0,    0,   57,
    0,    0,    0,   59,    0,    0,   61,    0,    0,    0,
    0,   56,   53,   58,    0,   57,   57,   57,   53,    0,
   54,   53,   83,   84,    0,   86,   54,    0,    0,   54,
    0,    0,   55,    0,    0,   59,    0,   53,   53,   53,
    0,    0,    0,   56,    0,   54,   54,   54,   57,    0,
    0,    0,    0,    0,    0,    0,    0,    0,   50,   50,
   50,   50,   50,   50,   50,   50,   50,   55,    0,    0,
   53,    0,    0,   55,    0,    0,   55,    0,   54,    0,
   57,    0,   43,   43,   43,   43,   43,   43,   43,   43,
   43,    0,   55,   55,   55,    0,    0,    0,    0,    0,
    0,    0,   53,    0,    0,    0,    0,    0,    0,    0,
   54,    0,   52,   52,   52,   52,   52,   52,   52,    0,
    0,    0,    0,    0,    0,   55,    0,    0,    0,    0,
    0,    0,    0,   74,    0,    0,    0,    0,   88,  154,
   81,   79,  153,   80,    0,   82,    0,    0,    0,   60,
   60,   60,   60,   60,   60,   60,    0,   55,   68,   72,
   69,    0,   78,   83,   84,    0,   86,    0,    0,    0,
    0,   61,   61,   61,   61,   61,   61,    0,   58,   58,
   58,   58,   58,    0,    0,    0,    0,    0,    0,   87,
    0,    0,   85,    0,    0,    0,    0,    0,    0,    0,
   59,   59,   59,   59,   59,    0,    0,    0,   56,   56,
   56,   56,   56,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,   74,    0,    0,    0,    0,
   88,  156,   81,   79,  155,   80,    0,   82,    0,    0,
    0,    0,    0,    0,    0,   57,   57,   57,   57,   57,
   68,   72,   69,    0,   78,    0,    0,    0,    0,   88,
    0,   81,   79,    0,   80,    0,   82,   53,   53,   53,
   53,   53,    0,    0,    0,   54,   54,   54,   54,   54,
   74,   87,    0,   78,   85,   88,  110,   81,   79,    0,
   80,   74,   82,    0,    0,    0,   88,  142,   81,   79,
    0,   80,    0,   82,    0,   68,   72,   69,    0,   78,
   87,    0,    0,   85,    0,    0,   68,   72,   69,    0,
   78,    0,   55,   55,   55,   55,   55,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   87,    0,    0,   85,
    0,    0,    0,    0,    0,    0,   74,   87,    0,    0,
   85,   88,  143,   81,   79,    0,   80,   74,   82,    0,
    0,    0,   88,  144,   81,   79,    0,   80,    0,   82,
    0,   68,   72,   69,    0,   78,    0,    0,    0,    0,
    0,    0,   68,   72,   69,    0,   78,    0,   67,   70,
   71,   73,   75,   76,   77,   83,   84,    0,   86,    0,
    0,    0,   87,    0,    0,   85,    0,    0,    0,    0,
    0,    0,   74,   87,    0,    0,   85,   88,  145,   81,
   79,    0,   80,    0,   82,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,   68,   72,   69,
   74,   78,    0,    0,    0,   88,  148,   81,   79,    0,
   80,    0,   82,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,   68,   72,   69,   87,   78,
    0,   85,    0,    0,    0,    0,    0,    0,    0,    0,
   67,   70,   71,   73,   75,   76,   77,   83,   84,    0,
   86,    0,    0,    0,    0,    0,   87,    0,    0,   85,
    0,   74,    0,    0,    0,    0,   88,  150,   81,   79,
    0,   80,    0,   82,   76,   77,   83,   84,    0,   86,
    0,    0,    0,    0,    0,    0,   68,   72,   69,    0,
   78,    0,    0,    0,    0,   67,   70,   71,   73,   75,
   76,   77,   83,   84,    0,   86,   67,   70,   71,   73,
   75,   76,   77,   83,   84,    0,   86,   87,    0,    0,
   85,    0,    0,    0,    0,   74,    0,    0,    0,    0,
   88,  151,   81,   79,    0,   80,    0,   82,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   68,   72,   69,    0,   78,    0,    0,    0,    0,    0,
    0,   67,   70,   71,   73,   75,   76,   77,   83,   84,
    0,   86,   67,   70,   71,   73,   75,   76,   77,   83,
   84,   87,   86,   74,   85,    0,    0,    0,   88,  152,
   81,   79,    0,   80,   74,   82,    0,    0,    0,   88,
    0,   81,   79,  157,   80,    0,   82,    0,   68,   72,
   69,    0,   78,    0,    0,    0,    0,    0,    0,   68,
   72,   69,    0,   78,    0,    0,    0,   67,   70,   71,
   73,   75,   76,   77,   83,   84,    0,   86,    0,   87,
    0,    0,   85,    0,    0,    0,    0,    0,    0,    0,
   87,    0,    0,   85,    0,   67,   70,   71,   73,   75,
   76,   77,   83,   84,    0,   86,    0,    0,    0,   74,
    0,    0,    0,    0,   88,    0,   81,   79,  158,   80,
   74,   82,    0,    0,    0,   88,  164,   81,   79,    0,
   80,    0,   82,    0,   68,   72,   69,    0,   78,    0,
    0,    0,    0,    0,    0,   68,   72,   69,    0,   78,
    0,    0,    0,    0,    0,    0,   67,   70,   71,   73,
   75,   76,   77,   83,   84,   87,   86,    0,   85,    0,
    0,    0,    0,    0,    0,   74,   87,    0,    0,   85,
   88,  174,   81,   79,    0,   80,   74,   82,    0,    0,
    0,   88,  175,   81,   79,    0,   80,    0,   82,    0,
   68,   72,   69,    0,   78,    0,    0,    0,    0,    0,
    0,   68,   72,   69,    0,   78,    0,    0,    0,    0,
   67,   70,   71,   73,   75,   76,   77,   83,   84,    0,
   86,   87,    0,    0,   85,    0,    0,    0,    0,    0,
    0,    0,   87,    0,   74,   85,    0,    0,    0,   88,
  176,   81,   79,    0,   80,    0,   82,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   68,
   72,   69,    0,   78,    0,    0,    0,    0,   67,   70,
   71,   73,   75,   76,   77,   83,   84,    0,   86,   67,
   70,   71,   73,   75,   76,   77,   83,   84,    0,   86,
   87,   74,    0,   85,    0,    0,   88,  177,   81,   79,
    0,   80,    0,   82,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   68,   72,   69,    0,
   78,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,   87,    0,    0,
   85,    0,    0,    0,   67,   70,   71,   73,   75,   76,
   77,   83,   84,    0,   86,   67,   70,   71,   73,   75,
   76,   77,   83,   84,    0,   86,   30,    0,    0,   28,
    0,   29,    0,    0,   74,    0,    0,    0,    0,   88,
  178,   81,   79,    0,   80,    0,   82,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   68,
   72,   69,    0,   78,    0,    0,    0,    0,    0,    0,
   67,   70,   71,   73,   75,   76,   77,   83,   84,    0,
   86,   67,   70,   71,   73,   75,   76,   77,   83,   84,
   87,   86,   74,   85,    0,    0,    0,   88,    0,   81,
   79,    0,   80,   74,   82,    0,    0,    0,   88,   33,
   81,   79,   32,   80,    0,   82,    0,   68,   72,   69,
    0,   78,    0,    0,    0,    0,    0,    0,   68,   72,
   69,    0,   78,    0,    0,    0,    0,    0,    0,   67,
   70,   71,   73,   75,   76,   77,   83,   84,   87,   86,
   43,   85,    0,   28,    0,   29,    0,    0,    0,   87,
    0,    0,   85,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   67,   70,   71,   73,
   75,   76,   77,   83,   84,    0,   86,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,   33,    0,    0,   32,    0,    0,    0,
    0,    0,    0,    1,    0,    0,    2,    3,    4,    5,
    6,    7,    8,    9,    0,    0,   10,   11,   12,   13,
   14,   15,   16,   17,   18,   19,   20,   21,   22,   23,
   24,   25,   26,    0,   27,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,   31,    0,   67,
   70,   71,   73,   75,   76,   77,   83,   84,    0,   86,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,   67,   70,   71,
   73,   75,   76,   77,   83,   84,    0,   86,    0,   70,
   71,   73,   75,   76,   77,   83,   84,    1,   86,    0,
    2,    3,    4,    5,    6,    7,    8,    9,    0,    0,
   10,   11,   12,   13,   14,   15,   16,   17,   18,   19,
   20,   21,   22,   23,   24,   25,   26,   35,   27,    0,
    0,    0,    0,    0,    0,    0,    0,    0,   44,    0,
    0,   31,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,   61,    0,   63,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,   92,
   63,    0,    0,   94,   95,   96,   97,    0,    0,  100,
    0,  102,  103,  104,  105,  106,  107,  108,    0,  109,
    0,    0,    0,    0,  114,  115,  116,  117,  118,  119,
  120,  121,    0,  125,  126,  127,  128,  129,  130,  131,
  132,  133,    0,    0,    0,    0,  137,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  159,  160,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  161,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  166,    0,    0,    0,
  167,    0,  168,    0,  169,  170,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  179,
};
static const YYINT yycheck[] = {                         40,
    0,   44,   40,   90,  123,  287,   41,   44,   44,   44,
   44,    0,   40,   41,   40,   40,   42,   43,   40,   45,
   41,   47,   41,   44,   40,   44,   41,  266,  267,   44,
  270,   40,   44,   40,   44,   35,   40,   40,   64,    0,
   40,   41,   42,   43,   44,   45,   35,   47,    0,  136,
   93,  266,   41,   42,   43,   44,   45,   93,   47,   93,
   60,   61,   62,   40,   64,   91,   91,    0,   94,   94,
   40,   60,   61,   62,   35,   64,   40,   40,   40,   44,
   41,   42,   43,   44,   45,  123,   47,  125,  125,   41,
  125,   91,   44,   93,   94,  123,   40,   40,   40,   60,
   61,   62,   35,   64,   93,    0,  125,  123,   41,   42,
   43,   44,   45,  125,   47,  125,   40,  123,   41,   41,
    0,    0,   75,   -1,   -1,  125,   -1,   60,   61,   62,
   -1,   64,   93,    0,   -1,   -1,  125,   -1,   -1,   -1,
   35,   93,   -1,   -1,    0,   -1,   41,   42,   43,   44,
   45,  270,   47,   -1,   -1,   -1,   40,   -1,   42,   43,
   93,   45,   -1,   47,  125,   60,   61,   62,   35,   64,
    0,   -1,   -1,  125,   41,   42,   43,   44,   45,   35,
   47,   -1,   -1,   -1,   -1,   41,   42,   43,   44,   45,
    0,   47,  125,   60,   61,   62,   -1,   64,   93,   -1,
   -1,   -1,   -1,   33,   60,   61,   62,   91,   64,   -1,
   94,   -1,   -1,   43,   -1,   -1,   -1,   -1,    0,   -1,
   50,   51,   -1,   53,   -1,   35,   93,   -1,   -1,   -1,
  125,   41,   -1,   43,   44,   45,   -1,   93,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   75,   -1,   -1,   -1,   -1,
   60,   61,   62,   35,   64,   -1,   -1,   -1,  125,   41,
   42,   43,   44,   45,   -1,   47,   -1,   -1,   -1,  125,
  296,  297,  298,   -1,  300,  300,   -1,   -1,   60,   61,
   62,   -1,   64,   93,    0,   -1,   -1,  287,   -1,   -1,
  290,  291,  292,  293,  294,  295,  296,  297,  298,   -1,
  300,  290,  291,  292,  293,  294,  295,  296,  297,  298,
   -1,   93,   -1,   -1,   -1,  125,   -1,   -1,   -1,   35,
   -1,   -1,   -1,   -1,   -1,   41,   -1,   -1,   44,  290,
  291,  292,  293,  294,  295,  296,  297,  298,   -1,   -1,
   -1,   -1,   -1,  125,   60,   61,   62,   -1,   64,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  290,  291,  292,
  293,  294,  295,  296,  297,  298,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   93,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  290,  291,  292,  293,  294,
  295,  296,  297,  298,   -1,   40,   -1,   42,    0,  125,
   -1,   -1,   47,  297,  298,   -1,  300,   -1,   -1,   -1,
   -1,   -1,   -1,  290,  291,  292,  293,  294,  295,  296,
  297,  298,    0,   -1,  290,  291,  292,  293,  294,  295,
  296,  297,  298,   35,   -1,   -1,   -1,   -1,   -1,   41,
   42,   43,   44,   45,   -1,   47,   91,   -1,   -1,   94,
   -1,   -1,    0,   -1,   -1,   -1,   -1,   35,   60,   61,
   62,   -1,   64,   41,   42,   43,   44,   45,   -1,   47,
  290,  291,  292,  293,  294,  295,  296,   -1,   -1,   -1,
   -1,   -1,   60,   61,   62,   -1,   64,   35,   -1,    0,
   -1,   93,   -1,   41,   -1,   43,   44,   45,  290,  291,
  292,  293,  294,  295,  296,  297,  298,   -1,   -1,   -1,
   -1,    0,   60,   61,   62,   93,   64,   -1,    0,   -1,
   -1,   -1,   -1,  125,   35,   -1,   -1,   -1,   -1,   -1,
   41,   -1,   -1,   44,   -1,   -1,   40,   -1,   42,   43,
    0,   45,   -1,   47,   -1,   93,   35,  125,    0,   60,
   61,   62,   41,   35,   -1,   44,   -1,   -1,   -1,   41,
   64,   -1,   44,   -1,  290,  291,  292,  293,  294,  295,
  296,   60,   61,   62,   -1,   35,   -1,  125,   60,   61,
   62,   41,   93,   35,   44,    0,   -1,   91,   -1,   41,
   94,   -1,   44,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   60,   61,   62,   -1,   93,   -1,   -1,    0,   60,   61,
   62,   93,   -1,   -1,  125,    0,   -1,   -1,   -1,   -1,
   35,   -1,   -1,   -1,   -1,   -1,   41,   -1,   -1,   44,
   -1,   -1,   -1,   93,   -1,   -1,  125,   -1,   -1,   -1,
   -1,   93,   35,  125,   -1,   60,   61,   62,   41,   -1,
   35,   44,  297,  298,   -1,  300,   41,   -1,   -1,   44,
   -1,   -1,    0,   -1,   -1,  125,   -1,   60,   61,   62,
   -1,   -1,   -1,  125,   -1,   60,   61,   62,   93,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  290,  291,
  292,  293,  294,  295,  296,  297,  298,   35,   -1,   -1,
   93,   -1,   -1,   41,   -1,   -1,   44,   -1,   93,   -1,
  125,   -1,  290,  291,  292,  293,  294,  295,  296,  297,
  298,   -1,   60,   61,   62,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  125,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
  125,   -1,  290,  291,  292,  293,  294,  295,  296,   -1,
   -1,   -1,   -1,   -1,   -1,   93,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   35,   -1,   -1,   -1,   -1,   40,   41,
   42,   43,   44,   45,   -1,   47,   -1,   -1,   -1,  290,
  291,  292,  293,  294,  295,  296,   -1,  125,   60,   61,
   62,   -1,   64,  297,  298,   -1,  300,   -1,   -1,   -1,
   -1,  290,  291,  292,  293,  294,  295,   -1,  290,  291,
  292,  293,  294,   -1,   -1,   -1,   -1,   -1,   -1,   91,
   -1,   -1,   94,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
  290,  291,  292,  293,  294,   -1,   -1,   -1,  290,  291,
  292,  293,  294,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   35,   -1,   -1,   -1,   -1,
   40,   41,   42,   43,   44,   45,   -1,   47,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  290,  291,  292,  293,  294,
   60,   61,   62,   -1,   64,   -1,   -1,   -1,   -1,   40,
   -1,   42,   43,   -1,   45,   -1,   47,  290,  291,  292,
  293,  294,   -1,   -1,   -1,  290,  291,  292,  293,  294,
   35,   91,   -1,   64,   94,   40,   41,   42,   43,   -1,
   45,   35,   47,   -1,   -1,   -1,   40,   41,   42,   43,
   -1,   45,   -1,   47,   -1,   60,   61,   62,   -1,   64,
   91,   -1,   -1,   94,   -1,   -1,   60,   61,   62,   -1,
   64,   -1,  290,  291,  292,  293,  294,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   91,   -1,   -1,   94,
   -1,   -1,   -1,   -1,   -1,   -1,   35,   91,   -1,   -1,
   94,   40,   41,   42,   43,   -1,   45,   35,   47,   -1,
   -1,   -1,   40,   41,   42,   43,   -1,   45,   -1,   47,
   -1,   60,   61,   62,   -1,   64,   -1,   -1,   -1,   -1,
   -1,   -1,   60,   61,   62,   -1,   64,   -1,  290,  291,
  292,  293,  294,  295,  296,  297,  298,   -1,  300,   -1,
   -1,   -1,   91,   -1,   -1,   94,   -1,   -1,   -1,   -1,
   -1,   -1,   35,   91,   -1,   -1,   94,   40,   41,   42,
   43,   -1,   45,   -1,   47,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   60,   61,   62,
   35,   64,   -1,   -1,   -1,   40,   41,   42,   43,   -1,
   45,   -1,   47,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   60,   61,   62,   91,   64,
   -1,   94,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
  290,  291,  292,  293,  294,  295,  296,  297,  298,   -1,
  300,   -1,   -1,   -1,   -1,   -1,   91,   -1,   -1,   94,
   -1,   35,   -1,   -1,   -1,   -1,   40,   41,   42,   43,
   -1,   45,   -1,   47,  295,  296,  297,  298,   -1,  300,
   -1,   -1,   -1,   -1,   -1,   -1,   60,   61,   62,   -1,
   64,   -1,   -1,   -1,   -1,  290,  291,  292,  293,  294,
  295,  296,  297,  298,   -1,  300,  290,  291,  292,  293,
  294,  295,  296,  297,  298,   -1,  300,   91,   -1,   -1,
   94,   -1,   -1,   -1,   -1,   35,   -1,   -1,   -1,   -1,
   40,   41,   42,   43,   -1,   45,   -1,   47,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   60,   61,   62,   -1,   64,   -1,   -1,   -1,   -1,   -1,
   -1,  290,  291,  292,  293,  294,  295,  296,  297,  298,
   -1,  300,  290,  291,  292,  293,  294,  295,  296,  297,
  298,   91,  300,   35,   94,   -1,   -1,   -1,   40,   41,
   42,   43,   -1,   45,   35,   47,   -1,   -1,   -1,   40,
   -1,   42,   43,   44,   45,   -1,   47,   -1,   60,   61,
   62,   -1,   64,   -1,   -1,   -1,   -1,   -1,   -1,   60,
   61,   62,   -1,   64,   -1,   -1,   -1,  290,  291,  292,
  293,  294,  295,  296,  297,  298,   -1,  300,   -1,   91,
   -1,   -1,   94,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   91,   -1,   -1,   94,   -1,  290,  291,  292,  293,  294,
  295,  296,  297,  298,   -1,  300,   -1,   -1,   -1,   35,
   -1,   -1,   -1,   -1,   40,   -1,   42,   43,   44,   45,
   35,   47,   -1,   -1,   -1,   40,   41,   42,   43,   -1,
   45,   -1,   47,   -1,   60,   61,   62,   -1,   64,   -1,
   -1,   -1,   -1,   -1,   -1,   60,   61,   62,   -1,   64,
   -1,   -1,   -1,   -1,   -1,   -1,  290,  291,  292,  293,
  294,  295,  296,  297,  298,   91,  300,   -1,   94,   -1,
   -1,   -1,   -1,   -1,   -1,   35,   91,   -1,   -1,   94,
   40,   41,   42,   43,   -1,   45,   35,   47,   -1,   -1,
   -1,   40,   41,   42,   43,   -1,   45,   -1,   47,   -1,
   60,   61,   62,   -1,   64,   -1,   -1,   -1,   -1,   -1,
   -1,   60,   61,   62,   -1,   64,   -1,   -1,   -1,   -1,
  290,  291,  292,  293,  294,  295,  296,  297,  298,   -1,
  300,   91,   -1,   -1,   94,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   91,   -1,   35,   94,   -1,   -1,   -1,   40,
   41,   42,   43,   -1,   45,   -1,   47,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   60,
   61,   62,   -1,   64,   -1,   -1,   -1,   -1,  290,  291,
  292,  293,  294,  295,  296,  297,  298,   -1,  300,  290,
  291,  292,  293,  294,  295,  296,  297,  298,   -1,  300,
   91,   35,   -1,   94,   -1,   -1,   40,   41,   42,   43,
   -1,   45,   -1,   47,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   60,   61,   62,   -1,
   64,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   91,   -1,   -1,
   94,   -1,   -1,   -1,  290,  291,  292,  293,  294,  295,
  296,  297,  298,   -1,  300,  290,  291,  292,  293,  294,
  295,  296,  297,  298,   -1,  300,   40,   -1,   -1,   43,
   -1,   45,   -1,   -1,   35,   -1,   -1,   -1,   -1,   40,
   41,   42,   43,   -1,   45,   -1,   47,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   60,
   61,   62,   -1,   64,   -1,   -1,   -1,   -1,   -1,   -1,
  290,  291,  292,  293,  294,  295,  296,  297,  298,   -1,
  300,  290,  291,  292,  293,  294,  295,  296,  297,  298,
   91,  300,   35,   94,   -1,   -1,   -1,   40,   -1,   42,
   43,   -1,   45,   35,   47,   -1,   -1,   -1,   40,  123,
   42,   43,  126,   45,   -1,   47,   -1,   60,   61,   62,
   -1,   64,   -1,   -1,   -1,   -1,   -1,   -1,   60,   61,
   62,   -1,   64,   -1,   -1,   -1,   -1,   -1,   -1,  290,
  291,  292,  293,  294,  295,  296,  297,  298,   91,  300,
   40,   94,   -1,   43,   -1,   45,   -1,   -1,   -1,   91,
   -1,   -1,   94,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  290,  291,  292,  293,
  294,  295,  296,  297,  298,   -1,  300,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  123,   -1,   -1,  126,   -1,   -1,   -1,
   -1,   -1,   -1,  257,   -1,   -1,  260,  261,  262,  263,
  264,  265,  266,  267,   -1,   -1,  270,  271,  272,  273,
  274,  275,  276,  277,  278,  279,  280,  281,  282,  283,
  284,  285,  286,   -1,  288,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  301,   -1,  290,
  291,  292,  293,  294,  295,  296,  297,  298,   -1,  300,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  290,  291,  292,
  293,  294,  295,  296,  297,  298,   -1,  300,   -1,  291,
  292,  293,  294,  295,  296,  297,  298,  257,  300,   -1,
  260,  261,  262,  263,  264,  265,  266,  267,   -1,   -1,
  270,  271,  272,  273,  274,  275,  276,  277,  278,  279,
  280,  281,  282,  283,  284,  285,  286,    0,  288,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   11,   -1,
   -1,  301,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   28,   -1,   30,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   42,
   43,   -1,   -1,   46,   47,   48,   49,   -1,   -1,   52,
   -1,   54,   55,   56,   57,   58,   59,   60,   -1,   62,
   -1,   -1,   -1,   -1,   67,   68,   69,   70,   71,   72,
   73,   74,   -1,   76,   77,   78,   79,   80,   81,   82,
   83,   84,   -1,   -1,   -1,   -1,   89,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  111,  112,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  135,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  149,   -1,   -1,   -1,
  153,   -1,  155,   -1,  157,  158,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  171,
};
#define YYFINAL 34
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#define YYMAXTOKEN 302
#define YYUNDFTOKEN 318
#define YYTRANSLATE(a) ((a) > YYMAXTOKEN ? YYUNDFTOKEN : (a))
#if YYDEBUG
static const char *const yyname[] = {

"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,"'#'",0,0,"'&'",0,"'('","')'","'*'","'+'","','","'-'",0,"'/'",0,0,0,0,0,0,0,0,
0,0,0,0,"'<'","'='","'>'",0,"'@'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,"'['",0,"']'","'^'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,"'{'",0,"'}'","'~'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"INT","HEX","ERROR","UINT","M2_TRUE",
"M2_FALSE","CHAR","FLOAT","STRING","NAME","BLOCKNAME","IDENT","VARNAME",
"TYPENAME","SIZE","CAP","ORD","HIGH","ABS","MIN_FUNC","MAX_FUNC","FLOAT_FUNC",
"VAL","CHR","ODD","TRUNC","INC","DEC","INCL","EXCL","COLONCOLON","INTERNAL_VAR",
"ABOVE_COMMA","ASSIGN","LEQ","GEQ","NOTEQUAL","IN","OROR","LOGICAL_AND","DIV",
"MOD","UNARY","DOT","NOT","QID",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"illegal-symbol",
};
static const char *const yyrule[] = {
"$accept : start",
"start : exp",
"start : type_exp",
"type_exp : type",
"exp : exp '^'",
"$$1 :",
"exp : '-' $$1 exp",
"exp : '+' exp",
"exp : not_exp exp",
"not_exp : NOT",
"not_exp : '~'",
"exp : CAP '(' exp ')'",
"exp : ORD '(' exp ')'",
"exp : ABS '(' exp ')'",
"exp : HIGH '(' exp ')'",
"exp : MIN_FUNC '(' type ')'",
"exp : MAX_FUNC '(' type ')'",
"exp : FLOAT_FUNC '(' exp ')'",
"exp : VAL '(' type ',' exp ')'",
"exp : CHR '(' exp ')'",
"exp : ODD '(' exp ')'",
"exp : TRUNC '(' exp ')'",
"exp : SIZE exp",
"exp : INC '(' exp ')'",
"exp : INC '(' exp ',' exp ')'",
"exp : DEC '(' exp ')'",
"exp : DEC '(' exp ',' exp ')'",
"exp : exp DOT NAME",
"exp : set",
"exp : exp IN set",
"exp : INCL '(' exp ',' exp ')'",
"exp : EXCL '(' exp ',' exp ')'",
"set : '{' arglist '}'",
"set : type '{' arglist '}'",
"$$2 :",
"exp : exp '[' $$2 non_empty_arglist ']'",
"$$3 :",
"exp : exp '(' $$3 arglist ')'",
"arglist :",
"arglist : exp",
"arglist : arglist ',' exp",
"non_empty_arglist : exp",
"non_empty_arglist : non_empty_arglist ',' exp",
"exp : '{' type '}' exp",
"exp : type '(' exp ')'",
"exp : '(' exp ')'",
"exp : exp '@' exp",
"exp : exp '*' exp",
"exp : exp '/' exp",
"exp : exp DIV exp",
"exp : exp MOD exp",
"exp : exp '+' exp",
"exp : exp '-' exp",
"exp : exp '=' exp",
"exp : exp NOTEQUAL exp",
"exp : exp '#' exp",
"exp : exp LEQ exp",
"exp : exp GEQ exp",
"exp : exp '<' exp",
"exp : exp '>' exp",
"exp : exp LOGICAL_AND exp",
"exp : exp OROR exp",
"exp : exp ASSIGN exp",
"exp : M2_TRUE",
"exp : M2_FALSE",
"exp : INT",
"exp : UINT",
"exp : CHAR",
"exp : FLOAT",
"exp : variable",
"exp : SIZE '(' type ')'",
"exp : STRING",
"block : fblock",
"fblock : BLOCKNAME",
"fblock : block COLONCOLON BLOCKNAME",
"variable : fblock",
"variable : INTERNAL_VAR",
"variable : block COLONCOLON NAME",
"variable : NAME",
"type : TYPENAME",

};
#endif

int      yydebug;
int      yynerrs;

int      yyerrflag;
int      yychar;
YYSTYPE  yyval;
YYSTYPE  yylval;

/* define the initial stack-sizes */
#ifdef YYSTACKSIZE
#undef YYMAXDEPTH
#define YYMAXDEPTH  YYSTACKSIZE
#else
#ifdef YYMAXDEPTH
#define YYSTACKSIZE YYMAXDEPTH
#else
#define YYSTACKSIZE 10000
#define YYMAXDEPTH  10000
#endif
#endif

#define YYINITSTACKSIZE 200

typedef struct {
    unsigned stacksize;
    YYINT    *s_base;
    YYINT    *s_mark;
    YYINT    *s_last;
    YYSTYPE  *l_base;
    YYSTYPE  *l_mark;
} YYSTACKDATA;
/* variables for the parser stack */
static YYSTACKDATA yystack;
#line 648 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"

#if 0  /* FIXME! */
int
overflow(a,b)
   long a,b;
{
   return (MAX_OF_TYPE(builtin_type_m2_int) - b) < a;
}

int
uoverflow(a,b)
   unsigned long a,b;
{
   return (MAX_OF_TYPE(builtin_type_m2_card) - b) < a;
}
#endif /* FIXME */

/* Take care of parsing a number (anything that starts with a digit).
   Set yylval and return the token type; update lexptr.
   LEN is the number of characters in it.  */

/*** Needs some error checking for the float case ***/

static int
parse_number (olen)
     int olen;
{
  char *p = lexptr;
  LONGEST n = 0;
  LONGEST prevn = 0;
  int c,i,ischar=0;
  int base = input_radix;
  int len = olen;
  int unsigned_p = number_sign == 1 ? 1 : 0;

  if(p[len-1] == 'H')
  {
     base = 16;
     len--;
  }
  else if(p[len-1] == 'C' || p[len-1] == 'B')
  {
     base = 8;
     ischar = p[len-1] == 'C';
     len--;
  }

  /* Scan the number */
  for (c = 0; c < len; c++)
  {
    if (p[c] == '.' && base == 10)
      {
	/* It's a float since it contains a point.  */
	yylval.dval = atof (p);
	lexptr += len;
	return FLOAT;
      }
    if (p[c] == '.' && base != 10)
       error("Floating point numbers must be base 10.");
    if (base == 10 && (p[c] < '0' || p[c] > '9'))
       error("Invalid digit \'%c\' in number.",p[c]);
 }

  while (len-- > 0)
    {
      c = *p++;
      n *= base;
      if( base == 8 && (c == '8' || c == '9'))
	 error("Invalid digit \'%c\' in octal number.",c);
      if (c >= '0' && c <= '9')
	i = c - '0';
      else
	{
	  if (base == 16 && c >= 'A' && c <= 'F')
	    i = c - 'A' + 10;
	  else
	     return ERROR;
	}
      n+=i;
      if(i >= base)
	 return ERROR;
      if(!unsigned_p && number_sign == 1 && (prevn >= n))
	 unsigned_p=1;		/* Try something unsigned */
      /* Don't do the range check if n==i and i==0, since that special
	 case will give an overflow error. */
      if(RANGE_CHECK && n!=i && i)
      {
	 if((unsigned_p && (unsigned)prevn >= (unsigned)n) ||
	    ((!unsigned_p && number_sign==-1) && -prevn <= -n))
	    range_error("Overflow on numeric constant.");
      }
	 prevn=n;
    }

  lexptr = p;
  if(*p == 'B' || *p == 'C' || *p == 'H')
     lexptr++;			/* Advance past B,C or H */

  if (ischar)
  {
     yylval.ulval = n;
     return CHAR;
  }
  else if ( unsigned_p && number_sign == 1)
  {
     yylval.ulval = n;
     return UINT;
  }
  else if((unsigned_p && (n<0))) {
     range_error("Overflow on numeric constant -- number too large.");
     /* But, this can return if range_check == range_warn.  */
  }
  yylval.lval = n;
  return INT;
}


/* Some tokens */

static struct
{
   char name[2];
   int token;
} tokentab2[] =
{
    { {'<', '>'},    NOTEQUAL 	},
    { {':', '='},    ASSIGN	},
    { {'<', '='},    LEQ	},
    { {'>', '='},    GEQ	},
    { {':', ':'},    COLONCOLON },

};

/* Some specific keywords */

struct keyword {
   char keyw[10];
   int token;
};

static struct keyword keytab[] =
{
    {"OR" ,   OROR	 },
    {"IN",    IN         },/* Note space after IN */
    {"AND",   LOGICAL_AND},
    {"ABS",   ABS	 },
    {"CHR",   CHR	 },
    {"DEC",   DEC	 },
    {"NOT",   NOT	 },
    {"DIV",   DIV    	 },
    {"INC",   INC	 },
    {"MAX",   MAX_FUNC	 },
    {"MIN",   MIN_FUNC	 },
    {"MOD",   MOD	 },
    {"ODD",   ODD	 },
    {"CAP",   CAP	 },
    {"ORD",   ORD	 },
    {"VAL",   VAL	 },
    {"EXCL",  EXCL	 },
    {"HIGH",  HIGH       },
    {"INCL",  INCL	 },
    {"SIZE",  SIZE       },
    {"FLOAT", FLOAT_FUNC },
    {"TRUNC", TRUNC	 },
};


/* Read one token, getting characters through lexptr.  */

/* This is where we will check to make sure that the language and the operators used are
   compatible  */

static int
yylex ()
{
  int c;
  int namelen;
  int i;
  char *tokstart;
  char quote;

 retry:

  prev_lexptr = lexptr;

  tokstart = lexptr;


  /* See if it is a special token of length 2 */
  for( i = 0 ; i < (int) (sizeof tokentab2 / sizeof tokentab2[0]) ; i++)
     if(DEPRECATED_STREQN(tokentab2[i].name, tokstart, 2))
     {
	lexptr += 2;
	return tokentab2[i].token;
     }

  switch (c = *tokstart)
    {
    case 0:
      return 0;

    case ' ':
    case '\t':
    case '\n':
      lexptr++;
      goto retry;

    case '(':
      paren_depth++;
      lexptr++;
      return c;

    case ')':
      if (paren_depth == 0)
	return 0;
      paren_depth--;
      lexptr++;
      return c;

    case ',':
      if (comma_terminates && paren_depth == 0)
	return 0;
      lexptr++;
      return c;

    case '.':
      /* Might be a floating point number.  */
      if (lexptr[1] >= '0' && lexptr[1] <= '9')
	break;			/* Falls into number code.  */
      else
      {
	 lexptr++;
	 return DOT;
      }

/* These are character tokens that appear as-is in the YACC grammar */
    case '+':
    case '-':
    case '*':
    case '/':
    case '^':
    case '<':
    case '>':
    case '[':
    case ']':
    case '=':
    case '{':
    case '}':
    case '#':
    case '@':
    case '~':
    case '&':
      lexptr++;
      return c;

    case '\'' :
    case '"':
      quote = c;
      for (namelen = 1; (c = tokstart[namelen]) != quote && c != '\0'; namelen++)
	if (c == '\\')
	  {
	    c = tokstart[++namelen];
	    if (c >= '0' && c <= '9')
	      {
		c = tokstart[++namelen];
		if (c >= '0' && c <= '9')
		  c = tokstart[++namelen];
	      }
	  }
      if(c != quote)
	 error("Unterminated string or character constant.");
      yylval.sval.ptr = tokstart + 1;
      yylval.sval.length = namelen - 1;
      lexptr += namelen + 1;

      if(namelen == 2)  	/* Single character */
      {
	   yylval.ulval = tokstart[1];
	   return CHAR;
      }
      else
	 return STRING;
    }

  /* Is it a number?  */
  /* Note:  We have already dealt with the case of the token '.'.
     See case '.' above.  */
  if ((c >= '0' && c <= '9'))
    {
      /* It's a number.  */
      int got_dot = 0, got_e = 0;
      char *p = tokstart;
      int toktype;

      for (++p ;; ++p)
	{
	  if (!got_e && (*p == 'e' || *p == 'E'))
	    got_dot = got_e = 1;
	  else if (!got_dot && *p == '.')
	    got_dot = 1;
	  else if (got_e && (p[-1] == 'e' || p[-1] == 'E')
		   && (*p == '-' || *p == '+'))
	    /* This is the sign of the exponent, not the end of the
	       number.  */
	    continue;
	  else if ((*p < '0' || *p > '9') &&
		   (*p < 'A' || *p > 'F') &&
		   (*p != 'H'))  /* Modula-2 hexadecimal number */
	    break;
	}
	toktype = parse_number (p - tokstart);
        if (toktype == ERROR)
	  {
	    char *err_copy = (char *) alloca (p - tokstart + 1);

	    memcpy (err_copy, tokstart, p - tokstart);
	    err_copy[p - tokstart] = 0;
	    error ("Invalid number \"%s\".", err_copy);
	  }
	lexptr = p;
	return toktype;
    }

  if (!(c == '_' || c == '$'
	|| (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')))
    /* We must have come across a bad character (e.g. ';').  */
    error ("Invalid character '%c' in expression.", c);

  /* It's a name.  See how long it is.  */
  namelen = 0;
  for (c = tokstart[namelen];
       (c == '_' || c == '$' || (c >= '0' && c <= '9')
	|| (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'));
       c = tokstart[++namelen])
    ;

  /* The token "if" terminates the expression and is NOT
     removed from the input stream.  */
  if (namelen == 2 && tokstart[0] == 'i' && tokstart[1] == 'f')
    {
      return 0;
    }

  lexptr += namelen;

  /*  Lookup special keywords */
  for(i = 0 ; i < (int) (sizeof(keytab) / sizeof(keytab[0])) ; i++)
     if(namelen == strlen(keytab[i].keyw) && DEPRECATED_STREQN(tokstart,keytab[i].keyw,namelen))
	   return keytab[i].token;

  yylval.sval.ptr = tokstart;
  yylval.sval.length = namelen;

  if (*tokstart == '$')
    {
      write_dollar_variable (yylval.sval);
      return INTERNAL_VAR;
    }

  /* Use token-type BLOCKNAME for symbols that happen to be defined as
     functions.  If this is not so, then ...
     Use token-type TYPENAME for symbols that happen to be defined
     currently as names of types; NAME for other symbols.
     The caller is not constrained to care about the distinction.  */
 {


    char *tmp = copy_name (yylval.sval);
    struct symbol *sym;

    if (lookup_partial_symtab (tmp))
      return BLOCKNAME;
    sym = lookup_symbol (tmp, expression_context_block,
			 VAR_DOMAIN, 0, NULL);
    if (sym && SYMBOL_CLASS (sym) == LOC_BLOCK)
      return BLOCKNAME;
    if (lookup_typename (copy_name (yylval.sval), expression_context_block, 1))
      return TYPENAME;

    if(sym)
    {
       switch(sym->aclass)
       {
       case LOC_STATIC:
       case LOC_REGISTER:
       case LOC_ARG:
       case LOC_REF_ARG:
       case LOC_REGPARM:
       case LOC_REGPARM_ADDR:
       case LOC_LOCAL:
       case LOC_LOCAL_ARG:
       case LOC_BASEREG:
       case LOC_BASEREG_ARG:
       case LOC_CONST:
       case LOC_CONST_BYTES:
       case LOC_OPTIMIZED_OUT:
       case LOC_COMPUTED:
       case LOC_COMPUTED_ARG:
	  return NAME;

       case LOC_TYPEDEF:
	  return TYPENAME;

       case LOC_BLOCK:
	  return BLOCKNAME;

       case LOC_UNDEF:
	  error("internal:  Undefined class in m2lex()");

       case LOC_LABEL:
       case LOC_UNRESOLVED:
	  error("internal:  Unforseen case in m2lex()");

       default:
	  error ("unhandled token in m2lex()");
	  break;
       }
    }
    else
    {
       /* Built-in BOOLEAN type.  This is sort of a hack. */
       if(DEPRECATED_STREQN(tokstart,"TRUE",4))
       {
	  yylval.ulval = 1;
	  return M2_TRUE;
       }
       else if(DEPRECATED_STREQN(tokstart,"FALSE",5))
       {
	  yylval.ulval = 0;
	  return M2_FALSE;
       }
    }

    /* Must be another type of name... */
    return NAME;
 }
}

#if 0		/* Unused */
static char *
make_qualname(mod,ident)
   char *mod, *ident;
{
   char *new = malloc(strlen(mod)+strlen(ident)+2);

   strcpy(new,mod);
   strcat(new,".");
   strcat(new,ident);
   return new;
}
#endif  /* 0 */

void
yyerror (msg)
     char *msg;
{
  if (prev_lexptr)
    lexptr = prev_lexptr;

  error ("A %s in expression, near `%s'.", (msg ? msg : "error"), lexptr);
}
#line 1346 "m2-exp.c"

#if YYDEBUG
#include <stdio.h>		/* needed for printf */
#endif

#include <stdlib.h>	/* needed for malloc, etc */
#include <string.h>	/* needed for memset */

/* allocate initial stack or double stack size, up to YYMAXDEPTH */
static int yygrowstack(YYSTACKDATA *data)
{
    int i;
    unsigned newsize;
    YYINT *newss;
    YYSTYPE *newvs;

    if ((newsize = data->stacksize) == 0)
        newsize = YYINITSTACKSIZE;
    else if (newsize >= YYMAXDEPTH)
        return YYENOMEM;
    else if ((newsize *= 2) > YYMAXDEPTH)
        newsize = YYMAXDEPTH;

    i = (int) (data->s_mark - data->s_base);
    newss = (YYINT *)realloc(data->s_base, newsize * sizeof(*newss));
    if (newss == 0)
        return YYENOMEM;

    data->s_base = newss;
    data->s_mark = newss + i;

    newvs = (YYSTYPE *)realloc(data->l_base, newsize * sizeof(*newvs));
    if (newvs == 0)
        return YYENOMEM;

    data->l_base = newvs;
    data->l_mark = newvs + i;

    data->stacksize = newsize;
    data->s_last = data->s_base + newsize - 1;
    return 0;
}

#if YYPURE || defined(YY_NO_LEAKS)
static void yyfreestack(YYSTACKDATA *data)
{
    free(data->s_base);
    free(data->l_base);
    memset(data, 0, sizeof(*data));
}
#else
#define yyfreestack(data) /* nothing */
#endif

#define YYABORT  goto yyabort
#define YYREJECT goto yyabort
#define YYACCEPT goto yyaccept
#define YYERROR  goto yyerrlab

int
YYPARSE_DECL()
{
    int yym, yyn, yystate;
#if YYDEBUG
    const char *yys;

    if ((yys = getenv("YYDEBUG")) != 0)
    {
        yyn = *yys;
        if (yyn >= '0' && yyn <= '9')
            yydebug = yyn - '0';
    }
#endif

    yynerrs = 0;
    yyerrflag = 0;
    yychar = YYEMPTY;
    yystate = 0;

#if YYPURE
    memset(&yystack, 0, sizeof(yystack));
#endif

    if (yystack.s_base == NULL && yygrowstack(&yystack) == YYENOMEM) goto yyoverflow;
    yystack.s_mark = yystack.s_base;
    yystack.l_mark = yystack.l_base;
    yystate = 0;
    *yystack.s_mark = 0;

yyloop:
    if ((yyn = yydefred[yystate]) != 0) goto yyreduce;
    if (yychar < 0)
    {
        if ((yychar = YYLEX) < 0) yychar = YYEOF;
#if YYDEBUG
        if (yydebug)
        {
            yys = yyname[YYTRANSLATE(yychar)];
            printf("%sdebug: state %d, reading %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
    }
    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: state %d, shifting to state %d\n",
                    YYPREFIX, yystate, yytable[yyn]);
#endif
        if (yystack.s_mark >= yystack.s_last && yygrowstack(&yystack) == YYENOMEM)
        {
            goto yyoverflow;
        }
        yystate = yytable[yyn];
        *++yystack.s_mark = yytable[yyn];
        *++yystack.l_mark = yylval;
        yychar = YYEMPTY;
        if (yyerrflag > 0)  --yyerrflag;
        goto yyloop;
    }
    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
        yyn = yytable[yyn];
        goto yyreduce;
    }
    if (yyerrflag) goto yyinrecovery;

    YYERROR_CALL("syntax error");

    goto yyerrlab;

yyerrlab:
    ++yynerrs;

yyinrecovery:
    if (yyerrflag < 3)
    {
        yyerrflag = 3;
        for (;;)
        {
            if ((yyn = yysindex[*yystack.s_mark]) && (yyn += YYERRCODE) >= 0 &&
                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: state %d, error recovery shifting\
 to state %d\n", YYPREFIX, *yystack.s_mark, yytable[yyn]);
#endif
                if (yystack.s_mark >= yystack.s_last && yygrowstack(&yystack) == YYENOMEM)
                {
                    goto yyoverflow;
                }
                yystate = yytable[yyn];
                *++yystack.s_mark = yytable[yyn];
                *++yystack.l_mark = yylval;
                goto yyloop;
            }
            else
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: error recovery discarding state %d\n",
                            YYPREFIX, *yystack.s_mark);
#endif
                if (yystack.s_mark <= yystack.s_base) goto yyabort;
                --yystack.s_mark;
                --yystack.l_mark;
            }
        }
    }
    else
    {
        if (yychar == YYEOF) goto yyabort;
#if YYDEBUG
        if (yydebug)
        {
            yys = yyname[YYTRANSLATE(yychar)];
            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
        yychar = YYEMPTY;
        goto yyloop;
    }

yyreduce:
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
                YYPREFIX, yystate, yyn, yyrule[yyn]);
#endif
    yym = yylen[yyn];
    if (yym)
        yyval = yystack.l_mark[1-yym];
    else
        memset(&yyval, 0, sizeof yyval);
    switch (yyn)
    {
case 3:
#line 210 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode(OP_TYPE);
		  write_exp_elt_type(yystack.l_mark[0].tval);
		  write_exp_elt_opcode(OP_TYPE);
		}
break;
case 4:
#line 219 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (UNOP_IND); }
break;
case 5:
#line 223 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ number_sign = -1; }
break;
case 6:
#line 225 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ number_sign = 1;
			  write_exp_elt_opcode (UNOP_NEG); }
break;
case 7:
#line 230 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode(UNOP_PLUS); }
break;
case 8:
#line 234 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (UNOP_LOGICAL_NOT); }
break;
case 11:
#line 242 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (UNOP_CAP); }
break;
case 12:
#line 246 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (UNOP_ORD); }
break;
case 13:
#line 250 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (UNOP_ABS); }
break;
case 14:
#line 254 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (UNOP_HIGH); }
break;
case 15:
#line 258 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (UNOP_MIN);
			  write_exp_elt_type (yystack.l_mark[-1].tval);
			  write_exp_elt_opcode (UNOP_MIN); }
break;
case 16:
#line 264 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (UNOP_MAX);
			  write_exp_elt_type (yystack.l_mark[-1].tval);
			  write_exp_elt_opcode (UNOP_MIN); }
break;
case 17:
#line 270 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (UNOP_FLOAT); }
break;
case 18:
#line 274 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (BINOP_VAL);
			  write_exp_elt_type (yystack.l_mark[-3].tval);
			  write_exp_elt_opcode (BINOP_VAL); }
break;
case 19:
#line 280 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (UNOP_CHR); }
break;
case 20:
#line 284 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (UNOP_ODD); }
break;
case 21:
#line 288 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (UNOP_TRUNC); }
break;
case 22:
#line 292 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (UNOP_SIZEOF); }
break;
case 23:
#line 297 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode(UNOP_PREINCREMENT); }
break;
case 24:
#line 301 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode(BINOP_ASSIGN_MODIFY);
			  write_exp_elt_opcode(BINOP_ADD);
			  write_exp_elt_opcode(BINOP_ASSIGN_MODIFY); }
break;
case 25:
#line 307 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode(UNOP_PREDECREMENT);}
break;
case 26:
#line 311 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode(BINOP_ASSIGN_MODIFY);
			  write_exp_elt_opcode(BINOP_SUB);
			  write_exp_elt_opcode(BINOP_ASSIGN_MODIFY); }
break;
case 27:
#line 317 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (STRUCTOP_STRUCT);
			  write_exp_string (yystack.l_mark[0].sval);
			  write_exp_elt_opcode (STRUCTOP_STRUCT); }
break;
case 29:
#line 326 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ error("Sets are not implemented.");}
break;
case 30:
#line 330 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ error("Sets are not implemented.");}
break;
case 31:
#line 334 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ error("Sets are not implemented.");}
break;
case 32:
#line 338 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ error("Sets are not implemented.");}
break;
case 33:
#line 340 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ error("Sets are not implemented.");}
break;
case 34:
#line 349 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ start_arglist(); }
break;
case 35:
#line 351 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (MULTI_SUBSCRIPT);
			  write_exp_elt_longcst ((LONGEST) end_arglist());
			  write_exp_elt_opcode (MULTI_SUBSCRIPT); }
break;
case 36:
#line 359 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ start_arglist (); }
break;
case 37:
#line 361 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (OP_FUNCALL);
			  write_exp_elt_longcst ((LONGEST) end_arglist ());
			  write_exp_elt_opcode (OP_FUNCALL); }
break;
case 39:
#line 370 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ arglist_len = 1; }
break;
case 40:
#line 374 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ arglist_len++; }
break;
case 41:
#line 379 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ arglist_len = 1; }
break;
case 42:
#line 384 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ arglist_len++; }
break;
case 43:
#line 389 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (UNOP_MEMVAL);
			  write_exp_elt_type (yystack.l_mark[-2].tval);
			  write_exp_elt_opcode (UNOP_MEMVAL); }
break;
case 44:
#line 395 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (UNOP_CAST);
			  write_exp_elt_type (yystack.l_mark[-3].tval);
			  write_exp_elt_opcode (UNOP_CAST); }
break;
case 45:
#line 401 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ }
break;
case 46:
#line 409 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (BINOP_REPEAT); }
break;
case 47:
#line 413 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (BINOP_MUL); }
break;
case 48:
#line 417 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (BINOP_DIV); }
break;
case 49:
#line 421 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (BINOP_INTDIV); }
break;
case 50:
#line 425 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (BINOP_REM); }
break;
case 51:
#line 429 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (BINOP_ADD); }
break;
case 52:
#line 433 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (BINOP_SUB); }
break;
case 53:
#line 437 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (BINOP_EQUAL); }
break;
case 54:
#line 441 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (BINOP_NOTEQUAL); }
break;
case 55:
#line 443 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (BINOP_NOTEQUAL); }
break;
case 56:
#line 447 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (BINOP_LEQ); }
break;
case 57:
#line 451 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (BINOP_GEQ); }
break;
case 58:
#line 455 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (BINOP_LESS); }
break;
case 59:
#line 459 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (BINOP_GTR); }
break;
case 60:
#line 463 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (BINOP_LOGICAL_AND); }
break;
case 61:
#line 467 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (BINOP_LOGICAL_OR); }
break;
case 62:
#line 471 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (BINOP_ASSIGN); }
break;
case 63:
#line 478 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (OP_BOOL);
			  write_exp_elt_longcst ((LONGEST) yystack.l_mark[0].ulval);
			  write_exp_elt_opcode (OP_BOOL); }
break;
case 64:
#line 484 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (OP_BOOL);
			  write_exp_elt_longcst ((LONGEST) yystack.l_mark[0].ulval);
			  write_exp_elt_opcode (OP_BOOL); }
break;
case 65:
#line 490 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (OP_LONG);
			  write_exp_elt_type (builtin_type_m2_int);
			  write_exp_elt_longcst ((LONGEST) yystack.l_mark[0].lval);
			  write_exp_elt_opcode (OP_LONG); }
break;
case 66:
#line 497 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{
			  write_exp_elt_opcode (OP_LONG);
			  write_exp_elt_type (builtin_type_m2_card);
			  write_exp_elt_longcst ((LONGEST) yystack.l_mark[0].ulval);
			  write_exp_elt_opcode (OP_LONG);
			}
break;
case 67:
#line 506 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (OP_LONG);
			  write_exp_elt_type (builtin_type_m2_char);
			  write_exp_elt_longcst ((LONGEST) yystack.l_mark[0].ulval);
			  write_exp_elt_opcode (OP_LONG); }
break;
case 68:
#line 514 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (OP_DOUBLE);
			  write_exp_elt_type (builtin_type_m2_real);
			  write_exp_elt_dblcst (yystack.l_mark[0].dval);
			  write_exp_elt_opcode (OP_DOUBLE); }
break;
case 70:
#line 524 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (OP_LONG);
			  write_exp_elt_type (builtin_type_int);
			  write_exp_elt_longcst ((LONGEST) TYPE_LENGTH (yystack.l_mark[-1].tval));
			  write_exp_elt_opcode (OP_LONG); }
break;
case 71:
#line 531 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode (OP_M2_STRING);
			  write_exp_string (yystack.l_mark[0].sval);
			  write_exp_elt_opcode (OP_M2_STRING); }
break;
case 72:
#line 538 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ yyval.bval = SYMBOL_BLOCK_VALUE(yystack.l_mark[0].sym); }
break;
case 73:
#line 542 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ struct symbol *sym
			    = lookup_symbol (copy_name (yystack.l_mark[0].sval), expression_context_block,
					     VAR_DOMAIN, 0, NULL);
			  yyval.sym = sym;}
break;
case 74:
#line 551 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ struct symbol *tem
			    = lookup_symbol (copy_name (yystack.l_mark[0].sval), yystack.l_mark[-2].bval,
					     VAR_DOMAIN, 0, NULL);
			  if (!tem || SYMBOL_CLASS (tem) != LOC_BLOCK)
			    error ("No function \"%s\" in specified context.",
				   copy_name (yystack.l_mark[0].sval));
			  yyval.sym = tem;
			}
break;
case 75:
#line 563 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ write_exp_elt_opcode(OP_VAR_VALUE);
			  write_exp_elt_block (NULL);
			  write_exp_elt_sym (yystack.l_mark[0].sym);
			  write_exp_elt_opcode (OP_VAR_VALUE); }
break;
case 77:
#line 575 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ struct symbol *sym;
			  sym = lookup_symbol (copy_name (yystack.l_mark[0].sval), yystack.l_mark[-2].bval,
					       VAR_DOMAIN, 0, NULL);
			  if (sym == 0)
			    error ("No symbol \"%s\" in specified context.",
				   copy_name (yystack.l_mark[0].sval));

			  write_exp_elt_opcode (OP_VAR_VALUE);
			  /* block_found is set by lookup_symbol.  */
			  write_exp_elt_block (block_found);
			  write_exp_elt_sym (sym);
			  write_exp_elt_opcode (OP_VAR_VALUE); }
break;
case 78:
#line 591 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ struct symbol *sym;
			  int is_a_field_of_this;

 			  sym = lookup_symbol (copy_name (yystack.l_mark[0].sval),
					       expression_context_block,
					       VAR_DOMAIN,
					       &is_a_field_of_this,
					       NULL);
			  if (sym)
			    {
			      if (symbol_read_needs_frame (sym))
				{
				  if (innermost_block == 0 ||
				      contained_in (block_found, 
						    innermost_block))
				    innermost_block = block_found;
				}

			      write_exp_elt_opcode (OP_VAR_VALUE);
			      /* We want to use the selected frame, not
				 another more inner frame which happens to
				 be in the same block.  */
			      write_exp_elt_block (NULL);
			      write_exp_elt_sym (sym);
			      write_exp_elt_opcode (OP_VAR_VALUE);
			    }
			  else
			    {
			      struct minimal_symbol *msymbol;
			      char *arg = copy_name (yystack.l_mark[0].sval);

			      msymbol =
				lookup_minimal_symbol (arg, NULL, NULL);
			      if (msymbol != NULL)
				{
				  write_exp_msymbol
				    (msymbol,
				     lookup_function_type (builtin_type_int),
				     builtin_type_int);
				}
			      else if (!have_full_symbols () && !have_partial_symbols ())
				error ("No symbol table is loaded.  Use the \"symbol-file\" command.");
			      else
				error ("No symbol \"%s\" in current context.",
				       copy_name (yystack.l_mark[0].sval));
			    }
			}
break;
case 79:
#line 642 "/usr/home/freebsd/omega/src/gnu/usr.bin/gdb/libgdb/../../../../contrib/gdb/gdb/m2-exp.y"
	{ yyval.tval = lookup_typename (copy_name (yystack.l_mark[0].sval),
						expression_context_block, 0); }
break;
#line 1950 "m2-exp.c"
    }
    yystack.s_mark -= yym;
    yystate = *yystack.s_mark;
    yystack.l_mark -= yym;
    yym = yylhs[yyn];
    if (yystate == 0 && yym == 0)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: after reduction, shifting from state 0 to\
 state %d\n", YYPREFIX, YYFINAL);
#endif
        yystate = YYFINAL;
        *++yystack.s_mark = YYFINAL;
        *++yystack.l_mark = yyval;
        if (yychar < 0)
        {
            if ((yychar = YYLEX) < 0) yychar = YYEOF;
#if YYDEBUG
            if (yydebug)
            {
                yys = yyname[YYTRANSLATE(yychar)];
                printf("%sdebug: state %d, reading %d (%s)\n",
                        YYPREFIX, YYFINAL, yychar, yys);
            }
#endif
        }
        if (yychar == YYEOF) goto yyaccept;
        goto yyloop;
    }
    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
        yystate = yytable[yyn];
    else
        yystate = yydgoto[yym];
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: after reduction, shifting from state %d \
to state %d\n", YYPREFIX, *yystack.s_mark, yystate);
#endif
    if (yystack.s_mark >= yystack.s_last && yygrowstack(&yystack) == YYENOMEM)
    {
        goto yyoverflow;
    }
    *++yystack.s_mark = (YYINT) yystate;
    *++yystack.l_mark = yyval;
    goto yyloop;

yyoverflow:
    YYERROR_CALL("yacc stack overflow");

yyabort:
    yyfreestack(&yystack);
    return (1);

yyaccept:
    yyfreestack(&yystack);
    return (0);
}
